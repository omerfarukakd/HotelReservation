
# -*- coding: utf-8 -*-
"""
Hotel Reservation System (6-month horizon) â€” DS/Algo heavy project with GUI
- Balanced Search Tree: AVL tree indexes rooms by room_id
- Pathfinding: A* suggests alternative dates/room types when no availability
- Sorting: mergesort + heapsort; Binary search: lower_bound for interval insertion
- Stack/Queue: undo/redo (stack), waitlist (queue)
- IO: JSON persistence + CSV exports
GUI: Tkinter/ttk (no external deps)
Author: generated by ChatGPT
"""
from __future__ import annotations

import json
import csv
import math
import hashlib
from dataclasses import dataclass, asdict
from datetime import date, datetime, timedelta
from typing import Any, Optional, List, Dict, Tuple, Callable
from collections import deque

# ---------------------------
# Utilities
# ---------------------------

DATE_FMT = "%Y-%m-%d"
HORIZON_DAYS = 180

def today() -> date:
    return date.today()

def parse_date(s: str) -> date:
    return datetime.strptime(s, DATE_FMT).date()

def fmt_date(d: date) -> str:
    return d.strftime(DATE_FMT)

def sha256(s: str) -> str:
    return hashlib.sha256(s.encode("utf-8")).hexdigest()

def clamp(x: float, lo: float, hi: float) -> float:
    return max(lo, min(hi, x))

# ---------------------------
# Binary Search (lower_bound)
# ---------------------------

def lower_bound(arr: List[Any], key: Any, key_fn: Callable[[Any], Any]) -> int:
    """First index where key_fn(arr[i]) >= key."""
    lo, hi = 0, len(arr)
    while lo < hi:
        mid = (lo + hi) // 2
        if key_fn(arr[mid]) < key:
            lo = mid + 1
        else:
            hi = mid
    return lo

# ---------------------------
# Sorting Algorithms
# ---------------------------

def mergesort(arr: List[Any], key_fn: Callable[[Any], Any]) -> List[Any]:
    if len(arr) <= 1:
        return arr[:]
    mid = len(arr) // 2
    left = mergesort(arr[:mid], key_fn)
    right = mergesort(arr[mid:], key_fn)
    i = j = 0
    out: List[Any] = []
    while i < len(left) and j < len(right):
        if key_fn(left[i]) <= key_fn(right[j]):
            out.append(left[i]); i += 1
        else:
            out.append(right[j]); j += 1
    out.extend(left[i:])
    out.extend(right[j:])
    return out

def heapsort(arr: List[Any], key_fn: Callable[[Any], Any]) -> List[Any]:
    """In-place heap sort (returns a new list)."""
    a = arr[:]
    n = len(a)

    def sift_down(i: int, end: int) -> None:
        while True:
            l = 2*i + 1
            r = 2*i + 2
            largest = i
            if l < end and key_fn(a[l]) > key_fn(a[largest]):
                largest = l
            if r < end and key_fn(a[r]) > key_fn(a[largest]):
                largest = r
            if largest == i:
                break
            a[i], a[largest] = a[largest], a[i]
            i = largest

    # build max heap
    for i in range(n//2 - 1, -1, -1):
        sift_down(i, n)
    # extract
    for end in range(n-1, 0, -1):
        a[0], a[end] = a[end], a[0]
        sift_down(0, end)
    return a

# ---------------------------
# AVL Tree (Balanced BST)
# ---------------------------

class AVLNode:
    __slots__ = ("key", "value", "left", "right", "height")
    def __init__(self, key: str, value: Any):
        self.key = key
        self.value = value
        self.left: Optional["AVLNode"] = None
        self.right: Optional["AVLNode"] = None
        self.height = 1

def _h(n: Optional[AVLNode]) -> int:
    return n.height if n else 0

def _upd(n: AVLNode) -> None:
    n.height = 1 + max(_h(n.left), _h(n.right))

def _bal(n: AVLNode) -> int:
    return _h(n.left) - _h(n.right)

def _rot_right(y: AVLNode) -> AVLNode:
    x = y.left
    assert x is not None
    t2 = x.right
    x.right = y
    y.left = t2
    _upd(y); _upd(x)
    return x

def _rot_left(x: AVLNode) -> AVLNode:
    y = x.right
    assert y is not None
    t2 = y.left
    y.left = x
    x.right = t2
    _upd(x); _upd(y)
    return y

class AVLTree:
    def __init__(self):
        self.root: Optional[AVLNode] = None

    def insert(self, key: str, value: Any) -> None:
        def _ins(node: Optional[AVLNode], key: str, value: Any) -> AVLNode:
            if node is None:
                return AVLNode(key, value)
            if key < node.key:
                node.left = _ins(node.left, key, value)
            elif key > node.key:
                node.right = _ins(node.right, key, value)
            else:
                node.value = value
                return node

            _upd(node)
            b = _bal(node)

            # LL
            if b > 1 and key < node.left.key:  # type: ignore
                return _rot_right(node)
            # RR
            if b < -1 and key > node.right.key:  # type: ignore
                return _rot_left(node)
            # LR
            if b > 1 and key > node.left.key:  # type: ignore
                node.left = _rot_left(node.left)  # type: ignore
                return _rot_right(node)
            # RL
            if b < -1 and key < node.right.key:  # type: ignore
                node.right = _rot_right(node.right)  # type: ignore
                return _rot_left(node)

            return node

        self.root = _ins(self.root, key, value)

    def search(self, key: str) -> Optional[Any]:
        n = self.root
        while n:
            if key < n.key:
                n = n.left
            elif key > n.key:
                n = n.right
            else:
                return n.value
        return None

    def inorder_items(self) -> List[Tuple[str, Any]]:
        out: List[Tuple[str, Any]] = []
        def _dfs(n: Optional[AVLNode]) -> None:
            if not n:
                return
            _dfs(n.left)
            out.append((n.key, n.value))
            _dfs(n.right)
        _dfs(self.root)
        return out

# ---------------------------
# Domain Models
# ---------------------------

RoomType = str  # "FAMILY4" | "TRIPLE3" | "CELEB_FLOOR"

@dataclass
class Room:
    room_id: str
    display_name: str
    floor: int
    type: RoomType
    capacity: int
    base_price: int
    description: str
    features: List[str]

@dataclass
class Service:
    service_id: str
    name: str
    pricing: Dict[str, Any]  # mode, price

@dataclass
class Reservation:
    res_id: str
    created_at: str
    guest_name: str
    room_id: str
    room_type: RoomType
    check_in: str
    check_out: str
    adults: int
    children: int
    services: List[str]
    celeb_code_used: bool
    total_price: int

@dataclass
class MaintenanceWindow:
    mw_id: str
    scope: str  # "floor" or "room"
    scope_id: str  # floor number str or room_id
    start: str
    end: str

# ---------------------------
# Stack & Queue for Undo/Redo & Waitlist
# ---------------------------

class Command:
    def do(self, system: "HotelSystem") -> None:
        raise NotImplementedError
    def undo(self, system: "HotelSystem") -> None:
        raise NotImplementedError
    def label(self) -> str:
        return self.__class__.__name__

class ReserveCommand(Command):
    def __init__(self, reservation: Reservation):
        self.reservation = reservation
    def do(self, system: "HotelSystem") -> None:
        system._add_reservation_record(self.reservation)
    def undo(self, system: "HotelSystem") -> None:
        system._remove_reservation_record(self.reservation.res_id)

class CancelCommand(Command):
    def __init__(self, res_id: str):
        self.res_id = res_id
        self._snapshot: Optional[Reservation] = None
    def do(self, system: "HotelSystem") -> None:
        self._snapshot = system.get_reservation(self.res_id)
        if self._snapshot is None:
            raise ValueError("Reservation not found.")
        system._remove_reservation_record(self.res_id)
    def undo(self, system: "HotelSystem") -> None:
        if self._snapshot is None:
            return
        system._add_reservation_record(self._snapshot)

class MaintenanceCommand(Command):
    def __init__(self, mw: MaintenanceWindow, action: str):
        self.mw = mw
        self.action = action  # "add" or "remove"
    def do(self, system: "HotelSystem") -> None:
        if self.action == "add":
            system._add_maintenance_record(self.mw)
        else:
            system._remove_maintenance_record(self.mw.mw_id)
    def undo(self, system: "HotelSystem") -> None:
        if self.action == "add":
            system._remove_maintenance_record(self.mw.mw_id)
        else:
            system._add_maintenance_record(self.mw)

@dataclass
class WaitlistRequest:
    req_id: str
    guest_name: str
    room_type: RoomType
    check_in: str
    nights: int
    adults: int
    children: int
    services: List[str]
    celeb_code: str

# ---------------------------
# Core Hotel System
# ---------------------------

class HotelSystem:
    def __init__(self, data_dir: str):
        self.data_dir = data_dir

        self.rooms: Dict[str, Room] = {}
        self.services: Dict[str, Service] = {}
        self.reservations: Dict[str, Reservation] = {}
        self.maintenance: Dict[str, MaintenanceWindow] = {}

        # Indexes / DS
        self.room_index = AVLTree()                      # balanced BST
        self.room_reservations: Dict[str, List[Reservation]] = {}  # sorted by check_in per room
        self.waitlist: Dict[RoomType, deque[WaitlistRequest]] = {
            "FAMILY4": deque(),
            "TRIPLE3": deque(),
            "CELEB_FLOOR": deque(),
        }

        # Undo/Redo stacks
        self.undo_stack: List[Command] = []
        self.redo_stack: List[Command] = []

        # Celeb codes (hash list)
        self.celeb_hashes: set[str] = set()

        self.load_all()

    # ---------- Persistence ----------
    def _path(self, name: str) -> str:
        import os
        return os.path.join(self.data_dir, name)

    def load_all(self) -> None:
        self._load_rooms()
        self._load_services()
        self._load_celeb_codes()
        self._load_maintenance()
        self._load_reservations()

    def save_all(self) -> None:
        self._save_reservations()
        self._save_maintenance()

    def _load_rooms(self) -> None:
        with open(self._path("rooms.json"), "r", encoding="utf-8") as f:
            raw = json.load(f)
        self.rooms.clear()
        self.room_index = AVLTree()
        self.room_reservations.clear()
        for r in raw:
            r = dict(r)
            r.setdefault('display_name', f"Oda {r.get('room_id','')}")
            room = Room(**r)
            self.rooms[room.room_id] = room
            self.room_index.insert(room.room_id, room)
            self.room_reservations[room.room_id] = []

    def _load_services(self) -> None:
        with open(self._path("services.json"), "r", encoding="utf-8") as f:
            raw = json.load(f)
        self.services = {s["service_id"]: Service(**s) for s in raw}

    def _load_celeb_codes(self) -> None:
        with open(self._path("celeb_codes.json"), "r", encoding="utf-8") as f:
            raw = json.load(f)
        self.celeb_hashes = set(raw.get("hashes", []))

    def _load_maintenance(self) -> None:
        try:
            with open(self._path("maintenance.json"), "r", encoding="utf-8") as f:
                raw = json.load(f)
        except FileNotFoundError:
            raw = []
        self.maintenance = {m["mw_id"]: MaintenanceWindow(**m) for m in raw}

    def _load_reservations(self) -> None:
        with open(self._path("reservations.json"), "r", encoding="utf-8") as f:
            raw = json.load(f)
        self.reservations.clear()
        for rid in self.room_reservations:
            self.room_reservations[rid] = []
        for r in raw:
            res = Reservation(**r)
            self.reservations[res.res_id] = res
            self.room_reservations[res.room_id].append(res)
        # sort each room list by check_in using mergesort
        for rid, lst in self.room_reservations.items():
            self.room_reservations[rid] = mergesort(lst, key_fn=lambda x: parse_date(x.check_in))

    def _save_reservations(self) -> None:
        raw = [asdict(r) for r in self.reservations.values()]
        # stable sort by created_at for file readability
        raw = mergesort(raw, key_fn=lambda x: x["created_at"])
        with open(self._path("reservations.json"), "w", encoding="utf-8") as f:
            json.dump(raw, f, ensure_ascii=False, indent=2)

    def _save_maintenance(self) -> None:
        raw = [asdict(m) for m in self.maintenance.values()]
        raw = mergesort(raw, key_fn=lambda x: x["start"])
        with open(self._path("maintenance.json"), "w", encoding="utf-8") as f:
            json.dump(raw, f, ensure_ascii=False, indent=2)

    # ---------- Internal record ops (used by commands) ----------
    def _add_reservation_record(self, res: Reservation) -> None:
        if res.res_id in self.reservations:
            raise ValueError("Duplicate reservation id.")
        self.reservations[res.res_id] = res
        lst = self.room_reservations[res.room_id]
        idx = lower_bound(lst, parse_date(res.check_in), key_fn=lambda x: parse_date(x.check_in))
        lst.insert(idx, res)  # array insert: O(R)
        self._save_reservations()

    def _remove_reservation_record(self, res_id: str) -> None:
        res = self.reservations.pop(res_id, None)
        if res is None:
            return
        lst = self.room_reservations.get(res.room_id, [])
        for i, rr in enumerate(lst):
            if rr.res_id == res_id:
                lst.pop(i)
                break
        self._save_reservations()

    def _add_maintenance_record(self, mw: MaintenanceWindow) -> None:
        self.maintenance[mw.mw_id] = mw
        self._save_maintenance()

    def _remove_maintenance_record(self, mw_id: str) -> None:
        self.maintenance.pop(mw_id, None)
        self._save_maintenance()

    # ---------- Undo/Redo ----------
    def execute(self, cmd: Command) -> None:
        cmd.do(self)
        self.undo_stack.append(cmd)
        self.redo_stack.clear()

    def undo(self) -> Optional[str]:
        if not self.undo_stack:
            return None
        cmd = self.undo_stack.pop()
        cmd.undo(self)
        self.redo_stack.append(cmd)
        return cmd.label()

    def redo(self) -> Optional[str]:
        if not self.redo_stack:
            return None
        cmd = self.redo_stack.pop()
        cmd.do(self)
        self.undo_stack.append(cmd)
        return cmd.label()

    # ---------- Maintenance / availability ----------
    def _is_within_horizon(self, check_in: date, check_out: date) -> bool:
        if check_in < today():
            return False
        if (check_out - check_in).days <= 0:
            return False
        return check_out <= today() + timedelta(days=HORIZON_DAYS)

    @staticmethod
    def _overlap(a_start: date, a_end: date, b_start: date, b_end: date) -> bool:
        # [start, end) overlap
        return not (a_end <= b_start or b_end <= a_start)

    def _maintenance_blocks(self, room: Room, ci: date, co: date) -> bool:
        # If a floor is in maintenance for that period, all rooms on that floor are closed
        for mw in self.maintenance.values():
            ms, me = parse_date(mw.start), parse_date(mw.end)
            if not self._overlap(ci, co, ms, me):
                continue
            if mw.scope == "room" and mw.scope_id == room.room_id:
                return True
            if mw.scope == "floor" and int(mw.scope_id) == room.floor:
                return True
        return False

    def _room_has_conflict(self, room_id: str, ci: date, co: date) -> bool:
        lst = self.room_reservations[room_id]
        idx = lower_bound(lst, ci, key_fn=lambda x: parse_date(x.check_in))
        # check neighbor intervals only (because list is sorted by check_in)
        for j in (idx - 1, idx):
            if 0 <= j < len(lst):
                r = lst[j]
                rs, re = parse_date(r.check_in), parse_date(r.check_out)
                if self._overlap(ci, co, rs, re):
                    return True
        return False

    def find_available_rooms(self, room_type: RoomType, ci: date, co: date) -> List[Room]:
        if not self._is_within_horizon(ci, co):
            return []
        out: List[Room] = []
        for _, room in self.room_index.inorder_items():  # O(N)
            room = room  # type: ignore
            if room.type != room_type:
                continue
            if self._maintenance_blocks(room, ci, co):
                continue
            if self._room_has_conflict(room.room_id, ci, co):
                continue
            out.append(room)
        return out

    # ---------- Pricing ----------
    def _time_multiplier(self, ci: date) -> float:
        days_ahead = (ci - today()).days
        if days_ahead <= 10:
            return 1.50
        if days_ahead <= 30:
            return 1.25
        if days_ahead <= 120:
            return 1.00
        return 0.75  # 4-6 months

    def _demand_multiplier(self, room_type: RoomType, ci: date, co: date) -> float:
        # Use average availability ratio across the stay (simple)
        total_rooms = sum(1 for _, r in self.room_index.inorder_items() if r.type == room_type)  # type: ignore
        if total_rooms == 0:
            return 1.0
        # approximate: check availability on the check_in day only (fast), still meaningful for demo
        available = len(self.find_available_rooms(room_type, ci, ci + timedelta(days=1)))
        ratio = available / total_rooms
        # 1 + 0.60*(1-r)^2 ; between 1 and 1.60
        return 1.0 + 0.60 * (1.0 - ratio) * (1.0 - ratio)

    def _occupancy_ratio(self, room_type: RoomType, on_day: date) -> float:
        total_rooms = sum(1 for _, r in self.room_index.inorder_items() if r.type == room_type)  # type: ignore
        if total_rooms == 0:
            return 0.0
        available = len(self.find_available_rooms(room_type, on_day, on_day + timedelta(days=1)))
        return 1.0 - (available / total_rooms)

    def _people_multiplier(self, room: Room, adults: int, children: int) -> float:
        people = adults + children
        base_people = 2
        if people <= base_people:
            return 1.0
        extra = people - base_people
        # 3rd person +20%, 4th +15% (only if capacity allows)
        mult = 1.0
        if extra >= 1:
            mult *= 1.20
        if extra >= 2:
            mult *= 1.15
        # children discount: apply -20% on children share (approx)
        if children > 0:
            child_share = children / max(1, people)
            mult *= (1.0 - 0.20 * child_share)
        return mult

    def _services_price(self, services: List[str], nights: int, adults: int, children: int) -> int:
        people = adults + children
        total = 0
        for sid in services:
            srv = self.services.get(sid)
            if not srv:
                continue
            mode = srv.pricing.get("mode")
            price = int(srv.pricing.get("price", 0))
            if mode == "flat":
                total += price
            elif mode == "per_person":
                total += price * people
            elif mode == "per_night":
                total += price * nights
            elif mode == "per_person_per_night":
                total += price * people * nights
        return total

    def compute_price(self, room: Room, ci: date, co: date, adults: int, children: int, services: List[str]) -> int:
        nights = (co - ci).days
        tm = self._time_multiplier(ci)
        dm = self._demand_multiplier(room.type, ci, co)
        pm = self._people_multiplier(room, adults, children)
        base = room.base_price * nights
        extra = self._services_price(services, nights, adults, children)
        total = (base * tm * dm * pm) + extra
        return int(round(total))

    # ---------- Reservation API ----------
    def validate_celeb_code(self, code: str) -> bool:
        if not code:
            return False
        return sha256(code.strip()) in self.celeb_hashes

    def get_reservation(self, res_id: str) -> Optional[Reservation]:
        return self.reservations.get(res_id)

    def list_reservations(self) -> List[Reservation]:
        # Sort by check_in using mergesort
        return mergesort(list(self.reservations.values()), key_fn=lambda r: parse_date(r.check_in))

    def _new_id(self, prefix: str) -> str:
        # stable-ish id: prefix + epochms
        return f"{prefix}-{int(datetime.now().timestamp()*1000)}"

    def try_book(self, guest_name: str, room_type: RoomType, ci: date, nights: int,
                 adults: int, children: int, services: List[str], celeb_code: str = "") -> Tuple[bool, str, Optional[Reservation]]:
        co = ci + timedelta(days=nights)
        if not self._is_within_horizon(ci, co):
            return False, "Tarih aralÄ±ÄŸÄ± 6 ay sÄ±nÄ±rÄ± dÄ±ÅŸÄ±nda veya geÃ§ersiz.", None

        if adults <= 0 or (adults + children) <= 0:
            return False, "En az 1 yetiÅŸkin olmalÄ±.", None

        # celeb code requirement
        celeb_ok = True
        if room_type == "CELEB_FLOOR":
            celeb_ok = self.validate_celeb_code(celeb_code)
            if not celeb_ok:
                return False, "ÃœnlÃ¼ katÄ± iÃ§in Ã¶zel kod gerekli (demo kod: STAR2026).", None

        # capacity check (rough: room capacity)
        max_cap = 10 if room_type == "CELEB_FLOOR" else (4 if room_type == "FAMILY4" else 3)
        if adults + children > max_cap:
            return False, f"KiÅŸi sayÄ±sÄ± kapasiteyi aÅŸÄ±yor (max {max_cap}).", None

        available = self.find_available_rooms(room_type, ci, co)
        if not available:
            # add waitlist request
            req = WaitlistRequest(
                req_id=self._new_id("WQ"),
                guest_name=guest_name,
                room_type=room_type,
                check_in=fmt_date(ci),
                nights=nights,
                adults=adults,
                children=children,
                services=services[:],
                celeb_code=celeb_code or ""
            )
            self.waitlist[room_type].append(req)
            return False, "Uygun oda yok. Bekleme listesine eklendi; alternatif Ã¶neri alabilirsiniz.", None

        # pick best (cheapest computed) â€” use heapsort to rank
        priced: List[Tuple[int, Room]] = []
        for room in available:
            priced.append((self.compute_price(room, ci, co, adults, children, services), room))
        # heapsort sorts ascending if we sort by negative for max-heap output then reverse; easier: heapsort by price and take first
        priced_sorted = heapsort(priced, key_fn=lambda x: x[0])  # ascending
        best_price, best_room = priced_sorted[0]

        res = Reservation(
            res_id=self._new_id("RSV"),
            created_at=datetime.now().isoformat(timespec="seconds"),
            guest_name=guest_name.strip(),
            room_id=best_room.room_id,
            room_type=best_room.type,
            check_in=fmt_date(ci),
            check_out=fmt_date(co),
            adults=adults,
            children=children,
            services=services[:],
            celeb_code_used=(room_type == "CELEB_FLOOR"),
            total_price=int(best_price),
        )

        self.execute(ReserveCommand(res))
        self._try_fulfill_waitlist()  # optional: after a booking, still can fulfill others? usually after cancel, but harmless
        return True, f"Rezervasyon oluÅŸturuldu: {res.room_id} / Toplam: {res.total_price} TL", res

    def cancel(self, res_id: str) -> Tuple[bool, str]:
        if res_id not in self.reservations:
            return False, "Rezervasyon bulunamadÄ±."

        r = self.reservations[res_id]
        ci = parse_date(r.check_in)
        days_to_ci = (ci - today()).days

        # Policy: tomorrow (and same-day) reservations cannot be cancelled
        if days_to_ci <= 1:
            return False, "GiriÅŸ tarihi yarÄ±n/bugÃ¼n olan rezervasyonlar iptal edilemez."

        # Cancellation fee based on time remaining to check-in
        fee_rate = 0.03 if days_to_ci > 14 else 0.10
        penalty = int(round(float(r.total_price) * fee_rate))
        refund = int(float(r.total_price) - penalty)

        self.execute(CancelCommand(res_id))
        self._try_fulfill_waitlist()

        msg = (
            "Rezervasyon iptal edildi.\n"
            f"Kesinti: %{int(fee_rate * 100)}  ({penalty} TL)\n"
            f"Ä°ade: {refund} TL\n"
            f"(GiriÅŸe kalan gÃ¼n: {days_to_ci})"
        )
        return True, msg

    def _try_fulfill_waitlist(self) -> None:
        # When something changes (especially cancel), try to satisfy the earliest waitlist request for each type.
        for rtype, q in self.waitlist.items():
            if not q:
                continue
            req = q[0]
            ci = parse_date(req.check_in)
            ok, msg, res = self.try_book(
                req.guest_name, req.room_type, ci, req.nights, req.adults, req.children, req.services, req.celeb_code
            )
            if ok:
                q.popleft()

    # ---------- Maintenance API ----------
    def add_floor_maintenance(self, floor: int, start: date, end: date) -> Tuple[bool, str]:
        if end <= start:
            return False, "BitiÅŸ baÅŸlangÄ±Ã§tan sonra olmalÄ±."
        if start < today():
            return False, "GeÃ§miÅŸ tarihe tadilat eklenemez."
        if end > today() + timedelta(days=HORIZON_DAYS):
            return False, "6 ay sÄ±nÄ±rÄ± dÄ±ÅŸÄ±nda."
        mw = MaintenanceWindow(
            mw_id=self._new_id("MW"),
            scope="floor",
            scope_id=str(floor),
            start=fmt_date(start),
            end=fmt_date(end),
        )
        self.execute(MaintenanceCommand(mw, "add"))
        return True, "Tadilat aralÄ±ÄŸÄ± eklendi."

    def add_room_maintenance(self, room_id: str, start: date, end: date) -> Tuple[bool, str]:
        if room_id not in self.rooms:
            return False, "Oda bulunamadÄ±."
        if end <= start:
            return False, "BitiÅŸ baÅŸlangÄ±Ã§tan sonra olmalÄ±."
        if start < today():
            return False, "GeÃ§miÅŸ tarihe tadilat eklenemez."
        mw = MaintenanceWindow(
            mw_id=self._new_id("MW"),
            scope="room",
            scope_id=str(room_id),
            start=fmt_date(start),
            end=fmt_date(end),
        )
        self.execute(MaintenanceCommand(mw, "add"))
        return True, "Oda tadilata alÄ±ndÄ±."

    def remove_maintenance(self, mw_id: str) -> Tuple[bool, str]:
        mw = self.maintenance.get(mw_id)
        if not mw:
            return False, "Tadilat kaydÄ± bulunamadÄ±."
        self.execute(MaintenanceCommand(mw, "remove"))
        return True, "Tadilat kaydÄ± kaldÄ±rÄ±ldÄ±."

    def list_maintenance(self) -> List[MaintenanceWindow]:
        return mergesort(list(self.maintenance.values()), key_fn=lambda m: parse_date(m.start))

    # ---------- Reports / CSV ----------
    def export_occupancy_daily_csv(self, out_path: str, days: int = 60) -> None:
        days = int(clamp(days, 7, HORIZON_DAYS))
        start = today()
        types = ["FAMILY4", "TRIPLE3", "CELEB_FLOOR"]
        with open(out_path, "w", newline="", encoding="utf-8") as f:
            w = csv.writer(f)
            w.writerow(["date"] + [f"occupancy_{t}" for t in types])
            for i in range(days):
                d = start + timedelta(days=i)
                row = [fmt_date(d)]
                for t in types:
                    row.append(round(self._occupancy_ratio(t, d), 4))
                w.writerow(row)

    def export_revenue_monthly_csv(self, out_path: str) -> None:
        # Revenue grouped by month (YYYY-MM) of check_in
        rev: Dict[str, int] = {}
        for r in self.reservations.values():
            key = r.check_in[:7]
            rev[key] = rev.get(key, 0) + int(r.total_price)
        rows = [{"month": k, "revenue": v} for k, v in rev.items()]
        rows = mergesort(rows, key_fn=lambda x: x["month"])
        with open(out_path, "w", newline="", encoding="utf-8") as f:
            w = csv.writer(f)
            w.writerow(["month", "revenue"])
            for row in rows:
                w.writerow([row["month"], row["revenue"]])
    def suggest_knapsack_package(self, budget: int, nights: int, people: int) -> List[Tuple[str, int]]:
        """
        DP (0/1 Knapsack) kullanarak verilen bÃ¼tÃ§eyi (budget) taÅŸmayacak ÅŸekilde
        fiyatÄ± en yÃ¼ksek (dolayÄ±sÄ±yla en kapsamlÄ±) hizmet paketini oluÅŸturur.
        DS&A: Dynamic Programming implementation.
        """
        # 1. KullanÄ±labilir hizmetleri ve GERÃ‡EK fiyatlarÄ±nÄ± listele
        items = [] 
        for srv in self.services.values():
            try:
                # Fiyat hesaplama mantÄ±ÄŸÄ± (Service modeline uygun olmalÄ±)
                # self._services_price metodunu taklit ediyoruz veya direkt Ã§aÄŸÄ±rabiliriz 
                # ama tek tek hesaplamak iÃ§in basit mantÄ±k kuralÄ±m:
                base_price = int(srv.pricing.get("price", 0))
                mode = srv.pricing.get("mode", "per_night")
                
                final_price = base_price
                if mode == "per_night":
                    final_price = base_price * nights
                elif mode == "per_person":
                    final_price = base_price * people
                elif mode == "per_person_per_night":
                    final_price = base_price * nights * people
                # fixed ise base_price kalÄ±r

                # MantÄ±ksÄ±z veya bÃ¼tÃ§eyi tek baÅŸÄ±na aÅŸanlarÄ± ele
                if 0 < final_price <= budget:
                    items.append((srv.name, final_price))
            except:
                continue
        
        n = len(items)
        if n == 0:
            return []

        # 2. DP Tablosu (2D Array)
        dp = [[0] * (budget + 1) for _ in range(n + 1)]
        
        for i in range(1, n + 1):
            name, price = items[i-1]
            for w in range(1, budget + 1):
                if price <= w:
                    val_with = price + dp[i-1][w-price]
                    val_without = dp[i-1][w]
                    dp[i][w] = max(val_without, val_with)
                else:
                    dp[i][w] = dp[i-1][w]
                    
        # 3. Backtracking
        selected = []
        w = budget
        for i in range(n, 0, -1):
            if dp[i][w] != dp[i-1][w]:
                name, price = items[i-1]
                selected.append((name, price))
                w -= price
                
        return selected
    
    def suggest_holiday_packages(self, budget: int, start_date: date, nights: int, adults: int, children: int) -> List[Dict]:
        """
        BÃ¼tÃ§eye uygun komple tatil paketleri (Oda + Hizmetler) Ã¶nerir.
        Geriye paket listesi dÃ¶ner. Her paket:
        {
            "room": <Room Object>,
            "services": [(Name, Price), ...],
            "total_price": int,
            "room_price": int,
            "services_price": int
        }
        """
        suggestions = []
        end_date = start_date + timedelta(days=nights)
        people_count = adults + children
        seen_combinations = set()

        # Sort rooms to ensure deterministic order
        sorted_rooms = sorted(self.rooms.values(), key=lambda r: r.room_id)
        
        for room in sorted_rooms:
            # Grup anahtarÄ±: (Tip, Taban Fiyat)
            combo_key = (room.type, room.base_price)
            if combo_key in seen_combinations:
                continue

            # Check availability logic
            avail = self.find_available_rooms(room.type, start_date, end_date)
            
            if not avail:
                continue
                
            # Pick one room
            target_room = None
            for r in avail:
                if r.base_price == room.base_price:
                    target_room = r
                    break
            
            if not target_room:
                continue

            # 1. Oda FiyatÄ±nÄ± Hesapla (Hizmetsiz)
            room_price = self.compute_price(target_room, start_date, end_date, adults, children, [])
            
            if room_price > budget:
                continue 

            # 2. Kalan bÃ¼tÃ§e ile Knapsack Ã§alÄ±ÅŸtÄ±r
            remaining_budget = budget - room_price
            
            service_items = self.suggest_knapsack_package(remaining_budget, nights, people_count)
            services_cost = sum(item[1] for item in service_items)
            
            total_pkg_cost = room_price + services_cost
            
            suggestions.append({
                "room": target_room,
                "services": service_items,
                "total_price": total_pkg_cost,
                "room_price": room_price,
                "services_price": services_cost
            })
            
            seen_combinations.add(combo_key)

        # En pahalÄ± (bÃ¼tÃ§eyi en Ã§ok dolduran) seÃ§enekten ucuza doÄŸru sÄ±rala
        suggestions.sort(key=lambda x: x['total_price'], reverse=True)
        return suggestions






# ---------------------------
# GUI (Modern Tkinter)
# ---------------------------

import tkinter as tk
from tkinter import ttk, messagebox, filedialog
import customtkinter as ctk

class DatePickerPopup(ctk.CTkToplevel):
    """A lightweight calendar popup (no external deps)."""
    def __init__(self, master, initial: date, on_pick, *,
                 min_date: Optional[date] = None, max_date: Optional[date] = None):
        super().__init__(master)
        # self.withdraw() # CTK toplevel bug?
        # self.overrideredirect(False) # Default
        self.resizable(False, False)
        self.title("Tarih SeÃ§")

        self.on_pick = on_pick
        self.min_date = min_date
        self.max_date = max_date

        self.cur_year = initial.year
        self.cur_month = initial.month
        self.selected = initial

        # Theme-aware colors (reads from parent app if available)
        app = master.winfo_toplevel()
        # Fallback if app doesn't have attributes
        self.colors = getattr(app, 'colors', {
            'bg': '#2b2b2b', 'card': '#333333', 'text': '#DCE4EE', 'muted': '#A0A0A0', 'line': '#404040', 'accent': '#1F6AA5'
        })
        
        # self.configure(bg=self.colors['bg']) # CTK handles this via fg_color
        self._build()
        self._render()

        try:
            self.transient(master.winfo_toplevel())
        except: pass
        
        try:
            self.grab_set()
        except: pass
        
        self.focus_force() # Focus
        self._place_near(master)
        self.bind("<FocusOut>", lambda e: self._close_if_outside(e))
        
    def _close_if_outside(self, event):
        # close if focus lost to another window, simplified
        pass

    def _place_near(self, widget: tk.Widget) -> None:
        try:
            # widget.update_idletasks() # UNSAFE for some CTK widgets
            x = widget.winfo_rootx()
            y = widget.winfo_rooty() + widget.winfo_height() + 5
            # Ensure within screen bounds
            if x < 0: x = 0
            if y < 0: y = 0
            self.geometry(f"+{x}+{y}")
        except Exception:
            pass

    def _build(self) -> None:
        header = tk.Frame(self, bg=self.colors["bg"])
        header.pack(fill="x", padx=10, pady=(10, 6))

        btn_prev = tk.Button(header, text="â—€", command=self._prev_month,
                             bg=self.colors["card"], fg=self.colors["text"], bd=0, padx=10, pady=6,
                             activebackground=self.colors["line"], activeforeground=self.colors["text"], font=("Segoe UI", 12))
        btn_prev.pack(side="left")

        self.lbl = tk.Label(header, text="", bg=self.colors["bg"], fg=self.colors["text"],
                            font=("Segoe UI", 11, "bold"), width=15)
        self.lbl.pack(side="left", expand=True)

        btn_next = tk.Button(header, text="â–¶", command=self._next_month,
                             bg=self.colors["card"], fg=self.colors["text"], bd=0, padx=10, pady=6,
                             activebackground=self.colors["line"], activeforeground=self.colors["text"], font=("Segoe UI", 12))
        btn_next.pack(side="right")

        # weekdays
        wd = tk.Frame(self, bg=self.colors["bg"])
        wd.pack(fill="x", padx=10)
        days_str = ["Pzt", "Sal", "Ã‡ar", "Per", "Cum", "Cmt", "Paz"]
        for name in days_str:
            tk.Label(wd, text=name, bg=self.colors["bg"], fg=self.colors["muted"],
                     font=("Segoe UI", 8), width=4).pack(side="left", expand=True)

        self.grid = tk.Frame(self, bg=self.colors["bg"])
        self.grid.pack(padx=10, pady=(6, 10))

    def _days_in_month(self, y: int, m: int) -> int:
        if m == 12:
            return (date(y+1, 1, 1) - date(y, m, 1)).days
        return (date(y, m+1, 1) - date(y, m, 1)).days

    def _render(self) -> None:
        for w in self.grid.winfo_children():
            w.destroy()

        self.lbl.config(text=f"{datetime(self.cur_year, self.cur_month, 1).strftime('%B %Y')}")

        first = date(self.cur_year, self.cur_month, 1)
        pad = first.weekday()
        days = self._days_in_month(self.cur_year, self.cur_month)

        r = 0
        c = pad

        def is_disabled(dt):
            if self.min_date and dt < self.min_date: return True
            if self.max_date and dt > self.max_date: return True
            return False

        # padding
        for _ in range(pad):
            tk.Label(self.grid, text=" ", bg=self.colors["bg"], width=4).grid(row=r, column=_, padx=2, pady=2)

        for day in range(1, days + 1):
            d = date(self.cur_year, self.cur_month, day)
            disabled = is_disabled(d)

            is_sel = (d == self.selected)
            bg = self.colors['accent'] if is_sel else self.colors['card']
            fg = '#FFFFFF' if is_sel else self.colors['text']
            abg = '#9F67FF' if is_sel else self.colors['line']
            
            state = "disabled" if disabled else "normal"
            cursor = "arrow" if disabled else "hand2"
            dfg = self.colors.get("muted", "#555")

            btn = tk.Button(self.grid, text=str(day),
                            bg=bg, fg=fg, bd=0, width=4, padx=2, pady=6,
                            activebackground=abg, activeforeground=fg,
                            state=state, cursor=cursor, disabledforeground=dfg)
            
            if disabled:
                btn.config(bg=self.colors.get("panel", self.colors["bg"]))
            else:
                btn.config(command=lambda dd=d: self._pick(dd))
            
            btn.grid(row=r, column=c, padx=2, pady=2)
            
            c += 1
            if c == 7:
                c = 0
                r += 1




    def _prev_month(self) -> None:
        if self.cur_month == 1:
            self.cur_month = 12
            self.cur_year -= 1
        else:
            self.cur_month -= 1
        self._render()

    def _next_month(self) -> None:
        if self.cur_month == 12:
            self.cur_month = 1
            self.cur_year += 1
        else:
            self.cur_month += 1
        self._render()

    def _pick(self, d: date) -> None:
        self.selected = d
        try:
            self.on_pick(d)
        finally:
            self._close()

    def _close(self) -> None:
        try:
            self.grab_release()
        except Exception:
            pass
        self.destroy()



class DateEntry(ctk.CTkFrame):
    """Entry + calendar button. Stores date as YYYY-MM-DD."""
    def __init__(self, master, variable: tk.StringVar, *, min_date: Optional[date] = None, max_date: Optional[date] = None):
        super().__init__(master, fg_color="transparent")
        self.var = variable
        self.min_date = min_date
        self.max_date = max_date

        self.entry = ctk.CTkEntry(self, textvariable=self.var)
        self.entry.pack(side="left", fill="x", expand=True)

        self.btn = ctk.CTkButton(self, text="ðŸ“…", width=30, command=self.open)
        self.btn.pack(side="left", padx=(6, 0))

    def open(self) -> None:
        try:
            cur = parse_date(self.var.get().strip())
        except Exception:
            cur = today()
        DatePickerPopup(self.btn, cur, self._on_pick, min_date=self.min_date, max_date=self.max_date)

    def _on_pick(self, d: date) -> None:
        self.var.set(fmt_date(d))


class BudgetWizardDialog(ctk.CTkToplevel):
    def __init__(self, master):
        super().__init__(master)
        self.title("BÃ¼tÃ§e SihirbazÄ± - Tatil Paketi")
        self.geometry("380x420")
        self.resizable(False, False)
        self.result = None

        try:
             x = master.winfo_rootx() + 50
             y = master.winfo_rooty() + 50
             self.geometry(f"+{x}+{y}")
        except: pass

        self.transient(master)
        self.grab_set()

        ctk.CTkLabel(self, text="Tatil Parametreleri", font=("Segoe UI", 16, "bold")).pack(pady=15)

        f = ctk.CTkFrame(self, fg_color="transparent")
        f.pack(padx=20, fill="x")

        def _row(lbl, row):
            ctk.CTkLabel(f, text=lbl, anchor="w").grid(row=row, column=0, sticky="w", pady=6)
        
        # Date
        _row("GiriÅŸ Tarihi:", 0)
        self.date_var = ctk.StringVar(value=fmt_date(today()))
        DateEntry(f, self.date_var).grid(row=0, column=1, sticky="w", pady=6)

        # Budget
        _row("Maksimum BÃ¼tÃ§e (TL):", 1)
        self.budget_var = ctk.StringVar(value="5000")
        ctk.CTkEntry(f, textvariable=self.budget_var, width=140).grid(row=1, column=1, sticky="w", pady=6)

        # Nights
        _row("Gece SayÄ±sÄ±:", 2)
        self.nights_var = ctk.StringVar(value="3")
        self.sb_nights = ctk.CTkComboBox(f, variable=self.nights_var, values=[str(i) for i in range(1, 31)], width=140)
        self.sb_nights.grid(row=2, column=1, sticky="w", pady=6)

        # Adults
        _row("YetiÅŸkin:", 3)
        self.adults_var = ctk.StringVar(value="2")
        self.sb_adults = ctk.CTkComboBox(f, variable=self.adults_var, values=[str(i) for i in range(1, 6)], width=140)
        self.sb_adults.grid(row=3, column=1, sticky="w", pady=6)

        # Children
        _row("Ã‡ocuk:", 4)
        self.children_var = ctk.StringVar(value="0")
        self.sb_children = ctk.CTkComboBox(f, variable=self.children_var, values=[str(i) for i in range(0, 5)], width=140)
        self.sb_children.grid(row=4, column=1, sticky="w", pady=6)

        ctk.CTkButton(self, text="Uygun Paketleri Bul", command=self._on_ok, width=160).pack(pady=20)

    def _on_ok(self):
        try:
            b = int(self.budget_var.get())
            n = int(self.nights_var.get())
            a = int(self.adults_var.get())
            c = int(self.children_var.get())
            d = parse_date(self.date_var.get())
            self.result = (b, d, n, a, c)
            self.destroy()
        except ValueError:
            messagebox.showerror("Hata", "LÃ¼tfen geÃ§erli deÄŸerler girin.\nTarih formatÄ±: YYYY-MM-DD")
        except Exception as e:
            messagebox.showerror("Hata", str(e))

    def get_input(self):
        self.wait_window()
        return self.result


class PackageResultDialog(ctk.CTkToplevel):
    def __init__(self, master, packages, on_reserve_callback):
        super().__init__(master)
        self.title(f"{len(packages)} Uygun Paket Bulundu")
        self.geometry("700x550")
        self.packages = packages
        self.on_reserve = on_reserve_callback
        
        try:
             x = master.winfo_rootx() + 30
             y = master.winfo_rooty() + 30
             self.geometry(f"+{x}+{y}")
        except: pass
        
        self.transient(master)
        self.grab_set()

        # Header
        head = ctk.CTkFrame(self, fg_color="transparent")
        head.pack(fill="x", padx=10, pady=10)
        ctk.CTkLabel(head, text=f"BÃ¼tÃ§enize Uygun {len(packages)} SeÃ§enek", font=("Segoe UI", 14, "bold")).pack(side="left")

        # Scrollable Area
        self.scroll = ctk.CTkScrollableFrame(self)
        self.scroll.pack(fill="both", expand=True, padx=10, pady=(0, 10))

        for idx, pkg in enumerate(packages):
            self._build_card(idx, pkg)

    def _build_card(self, idx, pkg):
        card = ctk.CTkFrame(self.scroll, border_width=1, border_color="#555")
        card.pack(fill="x", pady=5)
        
        # Left: Info
        left = ctk.CTkFrame(card, fg_color="transparent")
        left.pack(side="left", fill="both", expand=True, padx=10, pady=5)
        
        room = pkg["room"]
        room_price = pkg["room_price"]
        total_price = pkg["total_price"]
        services = pkg["services"] # list of (name, price)
        
        ctk.CTkLabel(left, text=f"{room.type} - {room.display_name}", font=("Segoe UI", 13, "bold"), anchor="w").pack(fill="x")
        ctk.CTkLabel(left, text=f"Oda FiyatÄ±: {room_price} TL", text_color="#AAAAAA", anchor="w").pack(fill="x")
        
        # Services text
        srv_names = [s[0] for s in services]
        srv_txt = ", ".join(srv_names) if srv_names else "Ekstra Hizmet Yok"
        ctk.CTkLabel(left, text=f"Dahil Hizmetler: {srv_txt}", wraplength=400, anchor="w").pack(fill="x")
        
        # Right: Price & Action
        right = ctk.CTkFrame(card, fg_color="transparent")
        right.pack(side="right", padx=10, pady=5)
        
        ctk.CTkLabel(right, text=f"{total_price} TL", font=("Segoe UI", 16, "bold"), text_color="#4CC2FF").pack()
        
        ctk.CTkButton(right, text="SeÃ§ & Rezerve Et", width=120,
                      command=lambda p=pkg: self._on_select(p)).pack(pady=5)

    def _on_select(self, pkg):
        self.on_reserve(pkg)
        self.destroy()






class ModernHotelApp(ctk.CTk):
    def __init__(self, system: HotelSystem):
        super().__init__()
        self.system = system


        ctk.set_appearance_mode("Dark")
        ctk.set_default_color_theme("blue")

        self.title("Otel Rezervasyon â€” Modern GUI (CustomTkinter)")
        self.geometry("1400x800")
        self.minsize(1100, 680)

        # Theme palettes (dark / light)
        self.theme = "dark"
        # We use CTK's theme mechanism now, but keep some custom colors for specific needs
        # We use CTK's theme mechanism now, but keep some custom colors for specific needs
        self.palettes = {
            "dark": {
                "bg": "#0F172A",     # Slate 900
                "panel": "#1E293B",  # Slate 800
                "card": "#334155",   # Slate 700
                "card2": "#475569",  # Slate 600
                "text": "#F1F5F9",   # Slate 100
                "muted": "#94A3B8",  # Slate 400
                "accent": "#38BDF8", # Sky 400
                "accent2": "#0EA5E9",# Sky 500
                "danger": "#F43F5E", # Rose 500
                "line": "#475569",   # Slate 600
            },
            "light": {
                "bg": "#F8FAFC",     # Slate 50
                "panel": "#F1F5F9",  # Slate 100
                "card": "#FFFFFF",   # White
                "card2": "#E2E8F0",  # Slate 200
                "text": "#0F172A",   # Slate 900
                "muted": "#64748B",  # Slate 500
                "accent": "#0EA5E9", # Sky 500
                "accent2": "#0284C7",# Sky 600
                "danger": "#E11D48", # Rose 600
                "line": "#E2E8F0",   # Slate 200
            },
        }
        self.colors = dict(self.palettes[self.theme])

        # self.configure(bg=self.colors["bg"]) # CTK handles this
        # self._setup_style() # CTK handles this

        self.status_var = ctk.StringVar(value="HazÄ±r.")
        self.active_page = ctk.StringVar(value="book")

        self._build_layout()
        self.refresh_all()

    # ---------- Styling ----------
    def _setup_style(self) -> None:
        # CustomTkinter handles styling internally.
        pass

    # ---------- Layout ----------
    def _build_layout(self) -> None:
        # root container
        root = ctk.CTkFrame(self, fg_color=self.colors["panel"])
        root.pack(fill="both", expand=True)

        # Sidebar
        self.sidebar = ctk.CTkFrame(root, width=250, corner_radius=0, fg_color=self.colors["panel"])
        self.sidebar.pack(side="left", fill="y")
        self.sidebar.pack_propagate(False)

        brand = ctk.CTkFrame(self.sidebar, fg_color="transparent")
        brand.pack(fill="x", padx=24, pady=(32, 20))
        ctk.CTkLabel(brand, text="HOTEL", font=("Segoe UI", 24, "bold"), text_color=self.colors["accent"]).pack(anchor="w")
        ctk.CTkLabel(brand, text="Rezervasyon & YÃ¶netim", text_color=self.colors["muted"],
                     font=("Segoe UI", 13)).pack(anchor="w")
        
        # Subtle separator
        ctk.CTkFrame(brand, height=1, fg_color=self.colors["line"]).pack(fill="x", pady=(15, 5))
        
        ctk.CTkLabel(brand, text="ÃœnlÃ¼ Kodu: STAR2026", text_color=self.colors["text"],
                     font=("Segoe UI", 11, "bold")).pack(anchor="w")

        nav = ctk.CTkFrame(self.sidebar, fg_color="transparent")
        nav.pack(fill="x", padx=10, pady=10)

        self.nav_buttons: Dict[str, ctk.CTkButton] = {}
        def nav_btn(key: str, text: str, icon: str, anchor_override: str = "w"):
            b = ctk.CTkButton(nav, text=f"  {icon}  {text}", anchor=anchor_override,
                              fg_color="transparent", text_color=self.colors["text"],
                              hover_color=self.colors["line"],
                              height=40, font=("Segoe UI", 13),
                              command=lambda k=key: self.show_page(k))
            b.pack(fill="x", pady=4)
            self.nav_buttons[key] = b

        nav_btn("book", "Rezervasyon", "ðŸ§¾")
        nav_btn("reservations", "KayÄ±tlar", "ðŸ“š")
        nav_btn("preview", "Otel Ã–nizleme", "ðŸ¢")
        
        # User requested specific left alignment for this button
        nav_btn("maintenance", "Tadilat", "ðŸ› ï¸", anchor_override="w")
        
        nav_btn("reports", "Raporlar", "ðŸ“ˆ")
        nav_btn("help", "DS/Algo", "ðŸ§ ")

        # Sidebar footer actions
        foot = ctk.CTkFrame(self.sidebar, fg_color="transparent")
        foot.pack(side="bottom", fill="x", padx=10, pady=20)

        ctk.CTkButton(foot, text="Undo", fg_color=self.colors["card"], text_color=self.colors["text"],
                      hover_color=self.colors["line"], border_width=1, border_color=self.colors["line"],
                      command=self.on_undo).pack(fill="x", pady=4)
        ctk.CTkButton(foot, text="Redo", fg_color=self.colors["card"], text_color=self.colors["text"],
                      hover_color=self.colors["line"], border_width=1, border_color=self.colors["line"],
                      command=self.on_redo).pack(fill="x", pady=4)

        # Content area
        self.content = ctk.CTkFrame(root, fg_color="transparent") # transparent to show bg
        self.content.pack(side="right", fill="both", expand=True)

        # Topbar
        self.topbar = ctk.CTkFrame(self.content, fg_color="transparent", height=60)
        self.topbar.pack(fill="x", padx=30, pady=(20, 10))
        ctk.CTkLabel(self.topbar, text="Otel Rezervasyon", font=("Segoe UI", 24, "bold")).pack(side="left")

        # Theme toggle (Dark/Light)
        # CTK Switch is better for this
        self.theme_switch_var = ctk.StringVar(value="dark" if self.theme == "dark" else "light")
        self.theme_switch = ctk.CTkSwitch(
            self.topbar, text="KaranlÄ±k Mod", variable=self.theme_switch_var, onvalue="dark", offvalue="light",
            command=self._on_theme_toggle_switch
        )
        self.theme_switch.pack(side="right", padx=(20, 0))
        if self.theme == "dark":
            self.theme_switch.select()
        else:
            self.theme_switch.deselect()

        self.kpi_var = ctk.StringVar(value="â€”")
        ctk.CTkLabel(self.topbar, textvariable=self.kpi_var, text_color=self.colors["muted"],
                     font=("Segoe UI", 12)).pack(side="right")

        # Pages container
        self.pages = ctk.CTkFrame(self.content, fg_color="transparent")
        self.pages.pack(fill="both", expand=True, padx=30, pady=10)

        self.page_frames: Dict[str, ctk.CTkFrame] = {}
        self.page_frames["book"] = self._page_book(self.pages)
        self.page_frames["reservations"] = self._page_reservations(self.pages)
        self.page_frames["preview"] = self._page_preview(self.pages)
        self.page_frames["maintenance"] = self._page_maintenance(self.pages)
        self.page_frames["reports"] = self._page_reports(self.pages)
        self.page_frames["help"] = self._page_help(self.pages)

        for fr in self.page_frames.values():
            fr.place(relx=0, rely=0, relwidth=1, relheight=1)

        # Status bar
        self.status = ctk.CTkFrame(self.content, fg_color="transparent", height=30)
        self.status.pack(fill="x", padx=30, pady=(0, 20))
        ctk.CTkLabel(self.status, textvariable=self.status_var, text_color=self.colors["muted"],
                     font=("Segoe UI", 11)).pack(side="left")

        self.show_page("book")

    def _card(self, master, title: str, subtitle: str = "") -> ctk.CTkFrame:
        # Modern Card: Larger radius, subtle border in light mode for definition
        # CTK doesn't like "transparent" for border_color, so we use a real color.
        # If width is 0, it won't show anyway.
        border_c = self.colors["line"] 
        border_w = 1 if self.theme == "light" else 0
        
        card = ctk.CTkFrame(master, fg_color=self.colors["card"], corner_radius=16, 
                            border_width=border_w, border_color=border_c)
        
        hdr = ctk.CTkFrame(card, fg_color="transparent")
        hdr.pack(fill="x", padx=24, pady=(20, 10))
        
        ctk.CTkLabel(hdr, text=title, font=("Segoe UI", 18, "bold"), text_color=self.colors["text"]).pack(anchor="w")
        if subtitle:
            ctk.CTkLabel(hdr, text=subtitle, text_color=self.colors["muted"], 
                         font=("Segoe UI", 12)).pack(anchor="w", pady=(2, 0))
                         
        body = ctk.CTkFrame(card, fg_color="transparent")
        body.pack(fill="both", expand=True, padx=24, pady=(0, 24))
        card.body = body  # type: ignore
        return card

    # ---------- Pages ----------
    def _page_book(self, master) -> ctk.CTkFrame:
        fr = ctk.CTkFrame(master, fg_color="transparent")

        # Two-column layout
        grid = ctk.CTkFrame(fr, fg_color="transparent")
        grid.pack(fill="both", expand=True)

        grid.columnconfigure(0, weight=6, uniform="col")
        grid.columnconfigure(1, weight=4, uniform="col")
        grid.rowconfigure(0, weight=1)

        left = ctk.CTkFrame(grid, fg_color="transparent")
        right = ctk.CTkFrame(grid, fg_color="transparent")
        left.grid(row=0, column=0, sticky="nsew", padx=(0, 20))
        right.grid(row=0, column=1, sticky="nsew", padx=(0, 0))

        # --- Form card
        horizon_min = today()
        horizon_max = today() + timedelta(days=HORIZON_DAYS)

        self.guest_var = ctk.StringVar()
        self.type_var = ctk.StringVar(value="FAMILY4")
        self.checkin_var = ctk.StringVar(value=fmt_date(today() + timedelta(days=5)))
        self.nights_var = ctk.IntVar(value=2)
        self.adults_var = ctk.IntVar(value=2)
        self.children_var = ctk.IntVar(value=0)
        self.celeb_code_var = ctk.StringVar()

        form_card = self._card(left, "Rezervasyon OluÅŸtur", "Tarih seÃ§imi takvimlidir â€¢ 6 ay sÄ±nÄ±rÄ± uygulanÄ±r")
        form_card.pack(fill="x")

        form = form_card.body  # type: ignore

        # Grid form
        grid_form = ctk.CTkFrame(form, fg_color="transparent")
        grid_form.pack(fill="x")
        grid_form.columnconfigure(0, weight=0)
        grid_form.columnconfigure(1, weight=1)

        def field(row: int, label: str, widget: ctk.CTkBaseClass) -> None:
            ctk.CTkLabel(grid_form, text=label, text_color=self.colors["muted"],
                         font=("Segoe UI", 12, "bold")).grid(row=row, column=0, sticky="w", padx=(0, 15), pady=8)
            widget.grid(row=row, column=1, sticky="ew", pady=8)

        self.entry_guest = ctk.CTkEntry(grid_form, textvariable=self.guest_var)
        e_guest = self.entry_guest

        cb_type = ctk.CTkComboBox(grid_form, variable=self.type_var, values=["FAMILY4", "TRIPLE3", "CELEB_FLOOR"], state="readonly")
        de_ci = DateEntry(grid_form, self.checkin_var, min_date=horizon_min, max_date=horizon_max)

        # Nights (using Entry as spinbox is not available, valid numbers only)
        sp_n = ctk.CTkEntry(grid_form, textvariable=self.nights_var)

        # People row
        ppl = ctk.CTkFrame(grid_form, fg_color="transparent")
        ppl.columnconfigure(0, weight=1)
        ppl.columnconfigure(1, weight=1)

        leftp = ctk.CTkFrame(ppl, fg_color="transparent")
        rightp = ctk.CTkFrame(ppl, fg_color="transparent")
        leftp.grid(row=0, column=0, sticky="w")
        rightp.grid(row=0, column=1, sticky="e")

        ctk.CTkLabel(leftp, text="YetiÅŸkin", text_color=self.colors["muted"],
                     font=("Segoe UI", 12, "bold")).pack(side="left", padx=(0, 8))
        
        # Using OptionMenu/Combobox for small ranges
        sp_a = ctk.CTkComboBox(leftp, variable=self.adults_var, values=[str(i) for i in range(1, 11)], width=70)
        sp_a.pack(side="left")

        ctk.CTkLabel(rightp, text="Ã‡ocuk", text_color=self.colors["muted"],
                     font=("Segoe UI", 12, "bold")).pack(side="left", padx=(0, 8))
        sp_c = ctk.CTkComboBox(rightp, variable=self.children_var, values=[str(i) for i in range(11)], width=70)
        sp_c.pack(side="left")

        e_code = ctk.CTkEntry(grid_form, textvariable=self.celeb_code_var)
        self._celeb_entry = e_code
        self._celeb_label = ctk.CTkLabel(grid_form, text="ÃœnlÃ¼ Kodu", text_color=self.colors["muted"], font=("Segoe UI", 12, "bold"))

        field(0, "Misafir AdÄ±", e_guest)
        field(1, "Oda Tipi", cb_type)
        field(2, "GiriÅŸ Tarihi", de_ci)
        field(3, "Gece SayÄ±sÄ±", sp_n)
        field(4, "YetiÅŸkin / Ã‡ocuk", ppl)
        
        self._celeb_label.grid(row=5, column=0, sticky="w", padx=(0, 15), pady=8)
        self._celeb_entry.grid(row=5, column=1, sticky="ew", pady=8)
        def _update_celeb_visibility(*_):
            if self.type_var.get() == "CELEB_FLOOR":
                self._celeb_label.grid()
                self._celeb_entry.grid()
            else:
                self._celeb_label.grid_remove()
                self._celeb_entry.grid_remove()
                self.celeb_code_var.set("")
        self.type_var.trace_add("write", _update_celeb_visibility)
        _update_celeb_visibility()

        # actions (left)
        act = ctk.CTkFrame(left, fg_color="transparent")
        act.pack(fill="x", pady=20)
        ctk.CTkButton(act, text="Uygun Oda Ara", command=self.on_search).pack(side="left", padx=(0, 10))
        ctk.CTkButton(act, text="Rezervasyon Yap", command=self.on_book).pack(side="left", padx=(0, 10))

        ctk.CTkButton(act, text="BÃ¼tÃ§e SihirbazÄ± (DP)", fg_color="#7C3AED", 
                      hover_color="#6D28D9", width=140,
                      command=self.on_knapsack_suggest).pack(side="left", padx=(10, 0))

        # results card (left)
        res_card = self._card(left, "Uygun Odalar", "En ucuzdan listelenir â€¢ Oda adÄ± daha okunaklÄ±")
        res_card.pack(fill="both", expand=True, pady=(0, 0))
        res_body = res_card.body  # type: ignore

        # Treeview (standard ttk)
        cols = ("room", "floor", "type", "cap", "est_price")
        # We need a frame to contain the treeview and scrollbar
        tv_frame = ctk.CTkFrame(res_body, fg_color="transparent")
        tv_frame.pack(fill="both", expand=True)
        
        self.av_tree = ttk.Treeview(tv_frame, columns=cols, show="headings", height=14)
        for c, w in zip(cols, (360, 80, 120, 70, 140)):
            self.av_tree.heading(c, text=c)
            self.av_tree.column(c, width=w, anchor="w")
            
        vsb = ttk.Scrollbar(tv_frame, orient="vertical", command=self.av_tree.yview) # Standard scrollbar for treeview
        self.av_tree.configure(yscrollcommand=vsb.set)
        self.av_tree.pack(side="left", fill="both", expand=True)
        vsb.pack(side="right", fill="y")
        
        # --- Right: services on top
        srv_card = self._card(right, "Ekstra Hizmetler", "SeÃ§imler fiyata yansÄ±r (per-night / per-person vb.)")
        srv_card.pack(fill="x")
        srv_body = srv_card.body  # type: ignore

        self.service_vars = {}
        for sid, srv in self.system.services.items():
            v = ctk.BooleanVar(value=False)
            self.service_vars[sid] = v
            line = ctk.CTkFrame(srv_body, fg_color="transparent")
            line.pack(fill="x", pady=4)
            ctk.CTkCheckBox(
                line,
                text=srv.name,
                variable=v,
                font=("Segoe UI", 13),
                command=self.refresh_price_preview,
            ).pack(side="left")
            
            meta = f"{srv.pricing.get('mode')} â€¢ {srv.pricing.get('price')} TL"
            ctk.CTkLabel(line, text=meta, text_color=self.colors["muted"],
                      font=("Segoe UI", 11)).pack(side="right")

        # --- Right: price & occupancy
        price_card = self._card(right, "Fiyat & Doluluk", "Dinamik fiyat: zaman + talep + kiÅŸi + hizmetler")
        price_card.pack(fill="both", expand=True, pady=(20, 0))
        pc = price_card.body  # type: ignore

        self.price_preview = ctk.StringVar(value="â€”")
        ctk.CTkLabel(pc, textvariable=self.price_preview,
                  font=("Segoe UI", 14, "bold"), justify="left").pack(anchor="w")

        ctk.CTkFrame(pc, fg_color=self.colors["line"], height=2).pack(fill="x", pady=15)

        ctk.CTkLabel(pc, text="30 GÃ¼n Doluluk (yaklaÅŸÄ±k)",
                  font=("Segoe UI", 12, "bold")).pack(anchor="w", pady=(0, 10))

        # Canvas for chart - Standard Canvas is fine, just need bg match
        self.canvas = tk.Canvas(pc, height=190, bg=self.colors["card"], highlightthickness=0)
        self.canvas.pack(fill="x", pady=(0, 10))
        ctk.CTkLabel(pc, text="Ä°pucu: Doluluk arttÄ±kÃ§a talep Ã§arpanÄ± fiyatÄ± yÃ¼kseltir.",
                  text_color=self.colors["muted"], font=("Segoe UI", 11), wraplength=360, justify="left").pack(anchor="w")

        # traces
        for v in (self.type_var, self.checkin_var):
            v.trace_add("write", lambda *args: self.refresh_price_preview())
        for v in (self.nights_var, self.adults_var, self.children_var):
            v.trace_add("write", lambda *args: self.refresh_price_preview())
            
        # Bind scrolls
        self._bind_scroll(sp_n, self.nights_var, min_val=1, max_val=30)
        self._bind_scroll(sp_a, self.adults_var, min_val=1, max_val=10)
        self._bind_scroll(sp_c, self.children_var, min_val=0, max_val=10)

        return fr

    def _page_reservations(self, master) -> ctk.CTkFrame:
        fr = ctk.CTkFrame(master, fg_color="transparent")

        top = self._card(fr, "Rezervasyon KayÄ±tlarÄ±", "Filtrele, incele, iptal et â€¢ Ä°ptal sonrasÄ± bekleme listesi denenir")
        top.pack(fill="both", expand=True)

        body = top.body  # type: ignore

        # filter row
        frow = ctk.CTkFrame(body, fg_color="transparent")
        frow.pack(fill="x", pady=(0, 15))
        ctk.CTkLabel(frow, text="Ara:", text_color=self.colors["muted"], 
                     font=("Segoe UI", 12, "bold")).pack(side="left")
        self.filter_var = ctk.StringVar(value="")
        ent = ctk.CTkEntry(frow, textvariable=self.filter_var)
        ent.pack(side="left", fill="x", expand=True, padx=10)
        ctk.CTkButton(frow, text="Uygula", width=80, command=self.refresh_reservations).pack(side="left", padx=(0, 8))
        ctk.CTkButton(frow, text="Yenile", width=80, command=self.refresh_all).pack(side="left")

        cols = ("res_id", "guest", "room_id", "type", "check_in", "check_out", "people", "price")
        
        tv_frame = ctk.CTkFrame(body, fg_color="transparent")
        tv_frame.pack(fill="both", expand=True)
        
        self.res_tree = ttk.Treeview(tv_frame, columns=cols, show="headings")
        for c, w in zip(cols, (180, 160, 140, 110, 110, 110, 80, 110)):
            self.res_tree.heading(c, text=c)
            self.res_tree.column(c, width=w, anchor="w")

        vsb = ttk.Scrollbar(tv_frame, orient="vertical", command=self.res_tree.yview)
        self.res_tree.configure(yscrollcommand=vsb.set)
        self.res_tree.pack(side="left", fill="both", expand=True)
        vsb.pack(side="right", fill="y")

        act = ctk.CTkFrame(fr, fg_color="transparent")
        act.pack(fill="x", pady=(12, 0))
        ctk.CTkButton(act, text="SeÃ§ileni Ä°ptal Et", fg_color=self.colors["danger"], hover_color=self.colors["danger"], command=self.on_cancel_selected).pack(side="left")
        return fr

    def _page_preview(self, master) -> ctk.CTkFrame:
        fr = ctk.CTkFrame(master, fg_color="transparent")
        
        # Header with Date Picker
        head = ctk.CTkFrame(fr, fg_color="transparent")
        head.pack(fill="x", pady=(0, 15))
        
        ctk.CTkLabel(head, text="Otel Ã–nizleme", font=("Segoe UI", 20, "bold")).pack(side="left")
        ctk.CTkLabel(head, text="Tarih:", font=("Segoe UI", 12, "bold"), text_color=self.colors["muted"]).pack(side="left", padx=(30, 10))
        
        self.preview_date_var = ctk.StringVar(value=fmt_date(today()))
        DateEntry(head, self.preview_date_var).pack(side="left")
        
        ctk.CTkButton(head, text="GÃ¶rÃ¼ntÃ¼le", width=100, command=self._draw_preview_map).pack(side="left", padx=15)
        
        # Legend
        leg = ctk.CTkFrame(head, fg_color="transparent")
        leg.pack(side="right")
        
        def _dot(color, label):
            f = ctk.CTkFrame(leg, fg_color="transparent")
            f.pack(side="left", padx=8)
            ctk.CTkFrame(f, width=12, height=12, fg_color=color, corner_radius=3).pack(side="left", padx=(0,4))
            ctk.CTkLabel(f, text=label, font=("Segoe UI", 10)).pack(side="left")
            
        _dot("#2CC985", "Uygun")
        _dot("#E11D48", "Dolu")
        _dot("#94A3B8", "BakÄ±m")

        # Canvas container with scrollbar
        self.preview_container = ctk.CTkFrame(fr, fg_color="transparent")
        self.preview_container.pack(fill="both", expand=True)

        # Standard Canvas for drawing
        # We put it inside a frame AND attach a scrollbar
        self.preview_canvas = tk.Canvas(self.preview_container, bg=self.colors["card"], highlightthickness=0)
        self.preview_canvas.pack(side="left", fill="both", expand=True)
        
        # Scrollbar
        vsb = ctk.CTkScrollbar(self.preview_container, orientation="vertical", command=self.preview_canvas.yview)
        vsb.pack(side="right", fill="y")
        self.preview_canvas.configure(yscrollcommand=vsb.set)
        
        # Bind mousewheel to canvas
        def _on_canvas_scroll(event):
            if self.preview_canvas.winfo_exists():
                delta = -1 * (event.delta // 120)
                self.preview_canvas.yview_scroll(delta, "units")
                
        self.preview_canvas.bind("<MouseWheel>", _on_canvas_scroll)

        # Draw initial
        self.after(200, self._draw_preview_map)
        
        return fr

    # ---------------------------------------------------------
    # DEÄžÄ°ÅžTÄ°R: ModernHotelApp Class'Ä±ndaki _draw_preview_map metodu
    # ---------------------------------------------------------
    def _draw_preview_map(self) -> None:
        if not hasattr(self, "preview_canvas") or not self.preview_canvas.winfo_exists():
            return
            
        cv = self.preview_canvas
        cv.delete("all")
        
        w = cv.winfo_width()
        if w < 100: w = 900
        
        try:
            target_date = parse_date(self.preview_date_var.get())
        except:
            target_date = today()
            
        rooms_by_floor: Dict[int, List[Room]] = {}
        for r in self.system.rooms.values():
            if r.floor not in rooms_by_floor:
                rooms_by_floor[r.floor] = []
            rooms_by_floor[r.floor].append(r)
            
        floors = sorted(rooms_by_floor.keys(), reverse=True)
        if not floors: return
        
        # Layout metrics
        margin_x = 20
        margin_y = 20
        floor_h = 70
        room_w = 60
        room_gap = 10
        floor_gap = 25
        
        current_y = margin_y
        next_day = target_date + timedelta(days=1)
        
        for fl in floors:
            rooms_on_floor = sorted(rooms_by_floor[fl], key=lambda x: x.room_id)
            
            # Kat Etiketi
            cv.create_text(margin_x + 30, current_y + floor_h/2, text=f"Kat {fl}", 
                           fill=self.colors["text"], anchor="e", font=("Segoe UI", 12, "bold"))
            
            x = margin_x + 80
            for room in rooms_on_floor:
                if x + room_w > w:
                    x = margin_x + 80
                    current_y += floor_h + 5
                
                # Durum Kontrolleri
                in_maint = self.system._maintenance_blocks(room, target_date, next_day)
                in_res = self.system._room_has_conflict(room.room_id, target_date, next_day)
                
                # --- EKONOMÄ° GÃ–RSELLEÅžTÄ°RME (HEATMAP) ---
                # OdanÄ±n talep Ã§arpanÄ±nÄ± (Demand Multiplier) al
                dm = self.system._demand_multiplier(room.type, target_date, next_day)
                
                if in_maint:
                    color = "#475569" # Gri (BakÄ±m)
                    outline = "#1E293B"
                    textc = "#CBD5E1"
                    price_text = "BAKIM"
                elif in_res:
                    color = "#E11D48" # KÄ±rmÄ±zÄ± (Dolu)
                    outline = "#881337"
                    textc = "#FFE4E6"
                    price_text = "DOLU"
                else:
                    # Renk SkalasÄ±: YeÅŸil (Ucuz) -> Turuncu -> KÄ±rmÄ±zÄ± (PahalÄ±)
                    # dm genellikle 1.0 (Normal) ile 1.6 (Ã‡ok YoÄŸun) arasÄ±nda deÄŸiÅŸir.
                    ratio = (dm - 1.0) / 0.6 
                    ratio = max(0.0, min(1.0, ratio))
                    
                    # RGB Ä°nterpolasyon (YeÅŸil #10B981 -> KÄ±rmÄ±zÄ±ya yakÄ±n bir ton)
                    r = int(16 + (220-16) * ratio)
                    g = int(185 - (50-185) * ratio) # Green decreases
                    b = int(129 - (80-129) * ratio)
                    
                    # Daha canlÄ± renkler iÃ§in basit mantÄ±k:
                    # DÃ¼ÅŸÃ¼k talep: YeÅŸil, YÃ¼ksek talep: Turuncu/Kiremit
                    if ratio < 0.3: color = "#10B981" # YeÅŸil
                    elif ratio < 0.7: color = "#F59E0B" # Turuncu
                    else: color = "#EF4444" # KÄ±rmÄ±zÄ±
                    
                    outline = self.colors["line"]
                    textc = "#FFFFFF"
                    
                    # Tahmini fiyatÄ± hesapla (gÃ¶rsel ÅŸov iÃ§in)
                    est_price = self.system.compute_price(room, target_date, next_day, 2, 0, [])
                    price_text = f"{est_price}â‚º"

                # Kutuyu Ã§iz
                cv.create_rectangle(x, current_y, x + room_w, current_y + floor_h, 
                                    fill=color, outline=outline, width=1)
                
                # Oda No
                cv.create_text(x + room_w/2, current_y + floor_h/2 - 9, text=room.room_id,
                               fill=textc, font=("Segoe UI", 9, "bold"))
                
                # Fiyat YazÄ±sÄ±
                cv.create_text(x + room_w/2, current_y + floor_h/2 + 9, text=price_text,
                               fill=textc, font=("Segoe UI", 8))
                
                x += room_w + room_gap
            
            current_y += floor_h + floor_gap
            cv.create_line(margin_x, current_y - floor_gap/2, w - margin_x, current_y - floor_gap/2, 
                           fill=self.colors["line"], width=1)

        cv.configure(scrollregion=(0, 0, w, current_y + 50))

    def _page_maintenance(self, master) -> ctk.CTkFrame:
        fr = ctk.CTkFrame(master, fg_color="transparent")
        horizon_min = today()
        horizon_max = today() + timedelta(days=HORIZON_DAYS)

        card = self._card(fr, "Tadilat / KullanÄ±m DÄ±ÅŸÄ±", "Kat bazlÄ± veya oda bazlÄ± kapama yapabilirsin")
        card.pack(fill="both", expand=True)
        body = card.body  # type: ignore

        # ---------- Form (grid) ----------
        form = ctk.CTkFrame(body, fg_color="transparent")
        form.pack(fill="x")

        self.m_scope = ctk.StringVar(value="floor")
        self.m_floor = ctk.IntVar(value=10)

        # room choices
        self.m_room_choice = ctk.StringVar(value="")
        room_values = [f"{room.room_id} â€” {room.display_name}" for room in self.system.rooms.values()]
        room_values = mergesort(room_values, key_fn=lambda x: x)  # stable sort for UI

        self.m_start = ctk.StringVar(value=fmt_date(today() + timedelta(days=7)))
        self.m_end = ctk.StringVar(value=fmt_date(today() + timedelta(days=14)))

        form_grid = ctk.CTkFrame(form, fg_color="transparent")
        form_grid.pack(fill="x")
        form_grid.columnconfigure(0, weight=0)
        form_grid.columnconfigure(1, weight=1)

        def put(row: int, label_widget: ctk.CTkBaseClass, value_widget: ctk.CTkBaseClass) -> None:
            label_widget.grid(row=row, column=0, sticky="w", padx=(0, 15), pady=8)
            value_widget.grid(row=row, column=1, sticky="ew", pady=8)

        lbl_scope = ctk.CTkLabel(form_grid, text="TÃ¼r", text_color=self.colors["muted"],
                             font=("Segoe UI", 12, "bold"))
        cb_scope = ctk.CTkComboBox(form_grid, variable=self.m_scope, values=["floor", "room"], state="readonly")
        put(0, lbl_scope, cb_scope)

        # Floor row
        self._mw_floor_label = ctk.CTkLabel(form_grid, text="Kat", text_color=self.colors["muted"],
                                        font=("Segoe UI", 12, "bold"))
        # using ComboBox for floor range
        self._mw_floor_widget = ctk.CTkComboBox(form_grid, variable=self.m_floor, values=[str(i) for i in range(1, 21)])
        # Bind scroll
        self._bind_scroll(self._mw_floor_widget, self.m_floor, min_val=1, max_val=20)
        put(1, self._mw_floor_label, self._mw_floor_widget)

        # Room row
        self._mw_room_label = ctk.CTkLabel(form_grid, text="Oda", text_color=self.colors["muted"],
                                       font=("Segoe UI", 12, "bold"))
        self._mw_room_widget = ctk.CTkComboBox(form_grid, variable=self.m_room_choice, values=room_values, state="readonly")
        if room_values:
            self.m_room_choice.set(room_values[0])
        put(2, self._mw_room_label, self._mw_room_widget)

        # Dates
        put(3,
            ctk.CTkLabel(form_grid, text="BaÅŸlangÄ±Ã§", text_color=self.colors["muted"], font=("Segoe UI", 12, "bold")),
            DateEntry(form_grid, self.m_start, min_date=horizon_min, max_date=horizon_max),
        )
        put(4,
            ctk.CTkLabel(form_grid, text="BitiÅŸ", text_color=self.colors["muted"], font=("Segoe UI", 12, "bold")),
            DateEntry(form_grid, self.m_end, min_date=horizon_min, max_date=horizon_max),
        )

        btn_row = ctk.CTkFrame(form, fg_color="transparent")
        btn_row.pack(fill="x", pady=(10, 10))
        ctk.CTkButton(btn_row, text="Tadilat Ekle", command=self.on_add_maintenance).pack(anchor="w")

        def _update_room_filter(*_):
            # Filter rooms by selected floor if in 'room' mode or just generally
            try:
                fl = int(self.m_floor.get())
            except:
                fl = 0
            
            # Filter rooms where floor matches
            filtered = [f"{r.room_id} â€” {r.display_name}" for r in self.system.rooms.values() if r.floor == fl]
            filtered = mergesort(filtered, key_fn=lambda x: x)
            
            if not filtered:
                filtered = ["Kata uygun oda yok"]
                
            self._mw_room_widget.configure(values=filtered)
            if filtered:
                self.m_room_choice.set(filtered[0])

        def _update_scope(*_):
            scope = self.m_scope.get()
            if scope == "floor":
                self._mw_floor_label.configure(text="Kat")
                self._mw_floor_label.grid()
                self._mw_floor_widget.grid()
                
                self._mw_room_label.grid_remove()
                self._mw_room_widget.grid_remove()
            else:
                # Show Floor as Filter
                self._mw_floor_label.configure(text="Filtre (Kat)")
                self._mw_floor_label.grid()
                self._mw_floor_widget.grid()
                
                self._mw_room_label.grid()
                self._mw_room_widget.grid()
                _update_room_filter() # apply filter initially

        self.m_scope.trace_add("write", _update_scope)
        self.m_floor.trace_add("write", _update_room_filter)
        _update_scope()

        ctk.CTkFrame(body, fg_color=self.colors["line"], height=2).pack(fill="x", pady=15)

        # ---------- List (tree + scrollbar in a stable container) ----------
        list_wrap = ctk.CTkFrame(body, fg_color="transparent")
        list_wrap.pack(fill="both", expand=True)

        cols = ("mw_id", "scope", "scope_id", "start", "end")
        self.mw_tree = ttk.Treeview(list_wrap, columns=cols, show="headings", height=12)
        for c, w in zip(cols, (200, 90, 200, 120, 120)):
            self.mw_tree.heading(c, text=c)
            self.mw_tree.column(c, width=w, anchor="w")

        vsb = ttk.Scrollbar(list_wrap, orient="vertical", command=self.mw_tree.yview)
        self.mw_tree.configure(yscrollcommand=vsb.set)

        self.mw_tree.grid(row=0, column=0, sticky="nsew")
        vsb.grid(row=0, column=1, sticky="ns")

        list_wrap.columnconfigure(0, weight=1)
        list_wrap.rowconfigure(0, weight=1)

        act = ctk.CTkFrame(fr, fg_color="transparent")
        act.pack(fill="x", pady=(12, 0))
        ctk.CTkButton(act, text="SeÃ§ili TadilatÄ± Ä°ptal Et", fg_color=self.colors["danger"], hover_color=self.colors["danger"], command=self.on_remove_maintenance).pack(side="left")
        return fr


    def _page_reports(self, master) -> ctk.CTkFrame:
        fr = ctk.CTkFrame(master, fg_color="transparent")
        card = self._card(fr, "CSV RaporlarÄ±", "occupancy_daily.csv â€¢ revenue_monthly.csv")
        card.pack(fill="both", expand=True)
        body = card.body  # type: ignore

        ctk.CTkButton(body, text="Doluluk CSV DÄ±ÅŸa Aktar", command=self.on_export_occupancy).pack(anchor="w", pady=6)
        ctk.CTkButton(body, text="Gelir CSV DÄ±ÅŸa Aktar", command=self.on_export_revenue).pack(anchor="w", pady=6)

        ctk.CTkFrame(body, fg_color=self.colors["line"], height=2).pack(fill="x", pady=15)

        self.summary_var = ctk.StringVar(value="â€”")
        ctk.CTkLabel(body, text="HÄ±zlÄ± Ã–zet", font=("Segoe UI", 16, "bold")).pack(anchor="w", pady=(0, 6))
        ctk.CTkLabel(body, textvariable=self.summary_var, text_color=self.colors["muted"], 
                     font=("Segoe UI", 12), justify="left").pack(anchor="w")
        return fr

    def _page_help(self, master) -> ctk.CTkFrame:
        fr = ctk.CTkFrame(master, fg_color="transparent")
        
        # Header
        head = ctk.CTkFrame(fr, fg_color="transparent")
        head.pack(fill="x", pady=(0, 10))
        ctk.CTkLabel(head, text="Algoritma & Veri YapÄ±larÄ±", font=("Segoe UI", 20, "bold")).pack(side="left")
        ctk.CTkLabel(head, text="Proje Sunum DetaylarÄ±", text_color=self.colors["muted"], 
                     font=("Segoe UI", 12, "bold")).pack(side="left", padx=(15, 0))

        # Scrollable Container
        scroll = ctk.CTkScrollableFrame(fr, fg_color="transparent")
        scroll.pack(fill="both", expand=True)

        # Helper to make cards
        def algo_card(parent, title, badge, content_lines, complexity_lines):
            card = ctk.CTkFrame(parent, fg_color=self.colors["card"], corner_radius=10)
            card.pack(fill="x", pady=8)
            
            # Header
            h = ctk.CTkFrame(card, fg_color="transparent")
            h.pack(fill="x", padx=15, pady=(15, 10))
            
            ctk.CTkLabel(h, text=title, font=("Segoe UI", 15, "bold")).pack(side="left")
            ctk.CTkLabel(h, text=f" {badge} ", fg_color=self.colors["accent"], text_color="#FFF", corner_radius=6,
                         font=("Segoe UI", 11, "bold")).pack(side="right")
            
            # Content
            c = ctk.CTkFrame(card, fg_color="transparent")
            c.pack(fill="x", padx=15, pady=(0, 15))
            
            for line in content_lines:
                bullet = "â€¢" if not line.startswith("  ") else "-"
                ctk.CTkLabel(c, text=f"{bullet} {line.strip()}", anchor="w", justify="left", 
                             text_color=self.colors["text"], wraplength=800).pack(fill="x", pady=1)

            # Complexity Footer
            if complexity_lines:
                f = ctk.CTkFrame(card, fg_color="transparent") #self.colors["card2"]? No, just transparent
                f.pack(fill="x", padx=15, pady=(0, 15))
                ctk.CTkFrame(f, height=1, fg_color=self.colors["line"]).pack(fill="x", pady=(0, 8))
                
                for k, v in complexity_lines.items():
                    row = ctk.CTkFrame(f, fg_color="transparent")
                    row.pack(fill="x")
                    ctk.CTkLabel(row, text=k, anchor="w", font=("Segoe UI", 11, "bold"), 
                                 text_color=self.colors["muted"], width=100).pack(side="left")
                    ctk.CTkLabel(row, text=v, anchor="w", font=("Segoe UI", 11, "bold"), 
                                 text_color=self.colors["accent"]).pack(side="left")

        # 1. AVL Tree
        algo_card(scroll, "Dengeli Arama AÄŸacÄ± (AVL)", "Veri YapÄ±sÄ±",
            [
                "KullanÄ±m: Oda indeksleme (room_id -> Room nesnesi).",
                "Neden: Python dict yerine, dengeli aÄŸaÃ§ yapÄ±sÄ±nÄ±n performansÄ±nÄ± gÃ¶stermek iÃ§in.",
                "Mekanizma: Her eklemede (insert) yÃ¼kseklik farkÄ± (balance factor) kontrol edilir.",
                "Rotasyon: Dengesizlik varsa LL, RR, LR, RL rotasyonlarÄ± ile aÄŸaÃ§ dengelenir.",
                "Self-Balancing: AÄŸaÃ§ her zaman ~log(N) derinliktedir."
            ],
            {"Ekleme (Insert)": "O(log N)", "Arama (Search)": "O(log N)"}
        )



        # 3. Dynamic Programming
        algo_card(scroll, "Dinamik Programlama (Knapsack)", "Algoritma",
            [
                "KullanÄ±m: 'BÃ¼tÃ§e SihirbazÄ±' (0/1 Knapsack Problemi).",
                "Senaryo: BÃ¼tÃ§enize (W) en uygun tatil paketini (oda + hizmetler) oluÅŸturur.",
                "FormÃ¼l: dp[i][w] = max(dp[i-1][w], price + dp[i-1][w-price]).",
                "MantÄ±k: OdayÄ± seÃ§tikten sonra, kalan bÃ¼tÃ§eye en Ã§ok 'deÄŸer' katan hizmetleri ekler.",
                "SonuÃ§: ParanÄ±zÄ±n tam karÅŸÄ±lÄ±ÄŸÄ±nÄ± veren optimum paket."
            ],
            {"KarmaÅŸÄ±klÄ±k": "O(N * W)", "TÃ¼r": "Pseudo-Polynomial"}
        )

        # 4. Sorting & Binary Search
        algo_card(scroll, "SÄ±ralama ve Arama", "Algoritma",
            [
                "Merge Sort: Rezervasyon listelerini tarihe gÃ¶re sÄ±ralar (Stable Sort).",
                "Heap Sort: 'Uygun Odalar' listesinde en ucuz 10 odayÄ± bulmak iÃ§in (Min-Heap).",
                "Binary Search (Lower Bound): Yeni rezervasyonun, mevcut rezervasyonlar arasÄ±na",
                "Ã§akÄ±ÅŸma olmadan eklenebileceÄŸi konumu bulmak iÃ§in kullanÄ±lÄ±r."
            ],
            {"Merge Sort": "O(N log N)", "Heap Sort": "O(N log N)", "Binary Search": "O(log N)"}
        )

        # 5. Stack & Queue
        algo_card(scroll, "Stack & Queue", "Veri YapÄ±sÄ±",
            [
                "Stack (YÄ±ÄŸÄ±n): 'Geri Al / Ä°leri Al' (Undo/Redo) sistemi.",
                "  - Her iÅŸlem (Command) bir stack'e atÄ±lÄ±r. Geri alÄ±nÄ±nca pop edilir.",
                "Queue (Kuyruk): Bekleme Listesi (Waitlist).",
                "  - Oda boÅŸalÄ±nca, sÄ±radaki ilk kiÅŸi (FIFO) otomatik atanÄ±r."
            ],
            {"EriÅŸim": "O(1) (UÃ§lardan)", "YapÄ±": "LIFO (Stack) / FIFO (Queue)"}
        )

        return fr

    # ---------- Navigation ----------
    def show_page(self, key: str) -> None:
        self.active_page.set(key)
        self.page_frames[key].tkraise()
        for k, b in self.nav_buttons.items():
            if k == key:
                b.configure(fg_color=self.colors["line"])
            else:
                b.configure(fg_color="transparent")
        self.set_status(f"Sayfa: {key}")


    
    def _on_theme_toggle_switch(self) -> None:
        self.toggle_theme()

# ---------- Theme (Dark/Light) ----------
    def toggle_theme(self) -> None:
        """Switch theme using CTK's appearance mode."""
        self.theme = "light" if self.theme == "dark" else "dark"
        ctk.set_appearance_mode("Dark" if self.theme == "dark" else "Light")
        
        self.colors = dict(self.palettes[self.theme])
        
        # We need to manually update colors that are not managed by CTK or where we used specific color codes
        # In this implementation, most things are rebuilt or handled by CTK, but we might want to rebuild to refresh everything
        # perfectly, especially standard Tkinter widgets like Treeview.
        
        # For simplicity and robustness with the mixed usage (Treeview), let's rebuild.
        # But first avoid recursion if triggered by switch
        
        # Rebuilding the UI
        for child in list(self.winfo_children()):
            child.destroy()
            
        self._build_layout()
        self.refresh_all()
        
        # Restore active page
        # Note: state restoration is simplified here compared to original for brevity,
        # but in a real migration we'd want to preserve form values. 
        # For this task, getting the visual refresh is key.

    def _bind_scroll(self, widget: ctk.CTkBaseClass, variable: Any, cycle: bool = False, min_val: int = 0, max_val: int = 100) -> None:
        """Binds mouse scroll to increment/decrement a variable."""
        def _on_scroll(event):
            try:
                # Windows: event.delta (+120 or -120 usually)
                # Linux: event.num (4 up, 5 down)
                delta = 0
                if hasattr(event, "delta") and event.delta:
                    delta = 1 if event.delta > 0 else -1
                elif hasattr(event, "num"):
                    delta = 1 if event.num == 4 else -1
                
                if delta == 0: return

                current = variable.get()
                # Try handling int
                try:
                    val = int(current)
                    new_val = val + delta
                    if new_val < min_val: new_val = min_val
                    if new_val > max_val: new_val = max_val
                    variable.set(new_val)
                except ValueError:
                     pass # Not an int, maybe skip or handle strings if ComboBox has index
            except Exception:
                pass

        # Bind to widget and its internal entry if exists
        widget.bind("<MouseWheel>", _on_scroll)
        widget.bind("<Button-4>", _on_scroll)
        widget.bind("<Button-5>", _on_scroll)
        
        # CTK ComboBox internal parts
        if hasattr(widget, "_entry"):
            widget._entry.bind("<MouseWheel>", _on_scroll)
            widget._entry.bind("<Button-4>", _on_scroll)
            widget._entry.bind("<Button-5>", _on_scroll)
        if hasattr(widget, "_dropdown_menu"):
             # Dropdown canvas scroll is handled by CTK usually, but for value change when closed:
             pass

    def set_status(self, msg: str) -> None:
        if not self.winfo_exists(): return
        self.status_var.set(msg)

    def _get_selected_services(self) -> List[str]:
        return [sid for sid, v in self.service_vars.items() if v.get()]

    def _get_inputs(self) -> Tuple[str, RoomType, date, int, int, int, List[str], str]:
        guest = self.guest_var.get().strip()
        rtype = self.type_var.get()
        ci = parse_date(self.checkin_var.get().strip())
        nights = int(self.nights_var.get())
        adults = int(self.adults_var.get())
        children = int(self.children_var.get())
        services = self._get_selected_services()
        celeb_code = self.celeb_code_var.get().strip()
        return guest, rtype, ci, nights, adults, children, services, celeb_code

    def refresh_price_preview(self) -> None:
        try:
            guest, rtype, ci, nights, adults, children, services, code = self._get_inputs()
            co = ci + timedelta(days=nights)
            avail = self.system.find_available_rooms(rtype, ci, co)

            tm = self.system._time_multiplier(ci)
            dm = self.system._demand_multiplier(rtype, ci, co)

            if not avail:
                self.price_preview.set(
                    "Uygun oda yok.\n"
                    "â€¢ Bekleme listesine eklenir\n"
                    "â€¢ A* ile alternatif Ã¶ner al"
                )
            else:
                room = avail[0]
                price = self.system.compute_price(room, ci, co, adults, children, services)
                self.price_preview.set(
                    f"{fmt_date(ci)} â†’ {fmt_date(co)}  â€¢  {nights} gece\n"
                    f"Tahmini Toplam: {price} TL\n\n"
                    f"Zaman Ã§arpanÄ±: {tm:.2f}\n"
                    f"Talep Ã§arpanÄ±: {dm:.2f}\n"
                    f"KiÅŸi: {adults} yetiÅŸkin + {children} Ã§ocuk"
                )

            self._draw_availability_bars(rtype)
        except Exception:
            pass

    def _draw_availability_bars(self, rtype: RoomType) -> None:
        c = self.canvas
        c.delete("all")
        w = int(c.winfo_width() or 420)
        h = int(c.winfo_height() or 190)
        pad = 10
        days = 30
        bar_w = max(6, (w - 2*pad) // days)
        base_y = h - pad

        # title
        c.create_text(pad, pad, anchor="nw", text=f"{rtype} â€¢ 30 GÃ¼n", fill=self.colors["muted"], font=("Segoe UI", 9, "bold"))

        for i in range(days):
            d = today() + timedelta(days=i)
            occ = self.system._occupancy_ratio(rtype, d)  # 0..1
            bh = int((h - 2*pad - 18) * occ)
            x0 = pad + i * bar_w
            y0 = base_y - bh
            x1 = x0 + bar_w - 2
            y1 = base_y
            # gradient-ish
            r = int(70 + 140*occ)
            g = int(140 - 70*occ)
            b = int(255 - 80*occ)
            c.create_rectangle(x0, y0, x1, y1, fill=f"#{r:02x}{g:02x}{b:02x}", outline="")

    # ---------- Actions ----------
    def on_search(self) -> None:
        try:
            guest, rtype, ci, nights, adults, children, services, code = self._get_inputs()
            co = ci + timedelta(days=nights)
            rooms = self.system.find_available_rooms(rtype, ci, co)

            priced: List[Tuple[int, Room]] = []
            for room in rooms:
                priced.append((self.system.compute_price(room, ci, co, adults, children, services), room))
            priced = heapsort(priced, key_fn=lambda x: x[0])

            for i in self.av_tree.get_children():
                self.av_tree.delete(i)
            for idx, (price, room) in enumerate(priced[:120]):
                self.av_tree.insert("", "end", iid=room.room_id, values=(room.display_name, room.floor, room.type, room.capacity, price))

            self.set_status(f"{len(rooms)} uygun oda bulundu.")
            self.refresh_price_preview()
        except Exception as e:
            messagebox.showerror("Hata", str(e))

    def on_book(self) -> None:
        try:
            # Validate Guest Name first
            raw_name = self.guest_var.get().strip()
            if not raw_name:
                messagebox.showwarning("Eksik Bilgi", "LÃ¼tfen 'Misafir AdÄ±' alanÄ±nÄ± doldurunuz.")
                if hasattr(self, "entry_guest"):
                    self.entry_guest.focus_set()
                return

            guest, rtype, ci, nights, adults, children, services, code = self._get_inputs()
            # _get_inputs might default to "Misafir" if we didn't check above, 
            # but we checked raw_name so use that guest value (which will be raw_name if we change _get_inputs, or "Misafir" if empty)
            # Actually let's explicitly pass raw_name to be sure if _get_inputs still defaults
            if guest == "Misafir" and not raw_name: # Should be caught above, but safety
                 pass
            
            # Since we validated raw_name is not empty, guest from _get_inputs will be raw_name 
            # (unless _get_inputs looks like: `guest = var.get() or "Misafir"` -> "Misafir")
            # Let's fix _get_inputs too to avoid confusion.
            
            ok, msg, res = self.system.try_book(guest, rtype, ci, nights, adults, children, services, code)
            if ok:
                messagebox.showinfo("BaÅŸarÄ±lÄ±", msg)
            else:
                messagebox.showwarning("Bilgi", msg)
            self.refresh_all()
        except Exception as e:
            messagebox.showerror("Hata", str(e))




    def on_cancel_selected(self) -> None:
        sel = self.res_tree.selection()
        if not sel:
            messagebox.showinfo("SeÃ§im", "LÃ¼tfen bir rezervasyon seÃ§in.")
            return
        item = self.res_tree.item(sel[0])
        res_id = item["values"][0]
        ok, msg = self.system.cancel(res_id)
        if ok:
            messagebox.showinfo("Ä°ptal", msg)
        else:
            messagebox.showwarning("Ä°ptal", msg)
        self.refresh_all()

    def on_add_maintenance(self) -> None:
        try:
            start = parse_date(self.m_start.get().strip())
            end = parse_date(self.m_end.get().strip())

            scope = getattr(self, "m_scope", tk.StringVar(value="floor")).get()
            if scope == "room":
                choice = self.m_room_choice.get().strip()
                room_id = choice.split(" â€” ", 1)[0].strip() if choice else ""
                ok, msg = self.system.add_room_maintenance(room_id, start, end)
            else:
                floor = int(self.m_floor.get())
                ok, msg = self.system.add_floor_maintenance(floor, start, end)

            if ok:
                messagebox.showinfo("Tadilat", msg)
            else:
                messagebox.showwarning("Tadilat", msg)
            self.refresh_all()
        except Exception as e:
            messagebox.showerror("Hata", str(e))


    def on_remove_maintenance(self) -> None:
        sel = self.mw_tree.selection()
        if not sel:
            messagebox.showinfo("SeÃ§im", "LÃ¼tfen bir tadilat kaydÄ± seÃ§in.")
            return
        item = self.mw_tree.item(sel[0])
        mw_id = item["values"][0]
        ok, msg = self.system.remove_maintenance(mw_id)
        if ok:
            messagebox.showinfo("Tadilat", msg)
        else:
            messagebox.showwarning("Tadilat", msg)
        self.refresh_all()

    def on_export_occupancy(self) -> None:
        path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV", "*.csv")], initialfile="occupancy_daily.csv")
        if not path:
            return
        self.system.export_occupancy_daily_csv(path, days=60)
        messagebox.showinfo("CSV", f"YazÄ±ldÄ±: {path}")

    def on_export_revenue(self) -> None:
        path = filedialog.asksaveasfilename(defaultextension=".csv", filetypes=[("CSV", "*.csv")], initialfile="revenue_monthly.csv")
        if not path:
            return
        self.system.export_revenue_monthly_csv(path)
        messagebox.showinfo("CSV", f"YazÄ±ldÄ±: {path}")

    # ---------------------------------------------------------
    # EKLE: ModernHotelApp Class'Ä±nÄ±n iÃ§ine (Actions bÃ¶lÃ¼mÃ¼)
    # ---------------------------------------------------------
    def on_knapsack_suggest(self) -> None:
        dialog = BudgetWizardDialog(self)
        res = dialog.get_input()
        if not res: return
        
        budget, checkin_date, nights, adults, children = res
        
        # BÃ¼tÃ§eye uygun FULL paketleri (Oda + Hizmet) ara
        packages = self.system.suggest_holiday_packages(budget, checkin_date, nights, adults, children)
        
        if not packages:
            messagebox.showinfo("SonuÃ§", "Bu bÃ¼tÃ§e ve kriterlere uygun tatil paketi bulunamadÄ±.\nLÃ¼tfen bÃ¼tÃ§eyi artÄ±rmayÄ± veya tarih deÄŸiÅŸtirmeyi deneyin.")
            return
            
        # SonuÃ§larÄ± gÃ¶ster ve seÃ§tir
        # Callback iÃ§in lambda kullanÄ±rken adults/children'Ä± da paketliyoruz (ResultDialog'da zaten paket var ama)
        # Packages listesine adults/children ekleyelim ki apply ederken kullanalÄ±m
        for p in packages:
             p['adults'] = adults
             p['children'] = children
             p['nights'] = nights
             p['checkin'] = checkin_date

        PackageResultDialog(self, packages, self.apply_reservation_package)

    def apply_reservation_package(self, pkg: dict):
        """
        SeÃ§ilen paketi Rezervasyon ekranÄ±na uygular:
        1. Tab'Ä± deÄŸiÅŸtir
        2. Tarih, KiÅŸi, Gece doldur
        3. Hizmetleri seÃ§
        4. OdayÄ± bul ve listede seÃ§ili hale getir
        """
        room = pkg["room"]
        checkin = pkg["checkin"]
        nights = pkg["nights"]
        adults = pkg["adults"]
        children = pkg["children"]
        services = pkg["services"] # List of (Name, Price)

        # 1. Navigasyon
        self.show_page("book")
        
        # 2. Formu doldur
        if hasattr(self, "checkin_var"):
            self.checkin_var.set(fmt_date(checkin))
        if hasattr(self, "nights_var"):
            self.nights_var.set(nights)
        if hasattr(self, "adults_var"):
            self.adults_var.set(adults)
        if hasattr(self, "children_var"):
            self.children_var.set(children)
        
        # Oda tipini, seÃ§ilen odanÄ±n tipine ayarla (filtreleme iÃ§in)
        if hasattr(self, "type_var"):
            self.type_var.set(room.type)

        # 3. Hizmetleri ayarla
        target_services = {s[0] for s in services}
        for s_name, var in self.service_vars.items():
            if s_name in target_services:
                var.set(True)
            else:
                var.set(False)

        # 4. Arama yap (Listeyi yenile)
        self.on_search()
        
        # 5. Listede odayÄ± bul ve seÃ§
        # Treeview'da her satÄ±rÄ±n values=(RoomDisplayName, ..., ..., ..., Price)
        # Ancak biz arka planda populate yaparken iid olarak room_id kullanÄ±yor olabiliriz veya values[0]
        # _populate_rooms metoduna bakmak lazÄ±m ama ÅŸimdilik oda adÄ±ndan veya tipinden bulmaya Ã§alÄ±ÅŸalÄ±m.
        # En saÄŸlÄ±klÄ±sÄ± room.room_id.
        
        # Treeview'da arayalÄ±m
        found = None
        for item_id in self.av_tree.get_children():
            # item_id genellikle bizim insert ÅŸeklimize gÃ¶re deÄŸiÅŸir.
            # Kodda: self.av_tree.insert("", "end", iid=room.room_id, values=...)
            # EÄŸer iid olarak room_id kullanÄ±ldÄ±ysa:
            if item_id == room.room_id:
                found = item_id
                break
        
        if found:
            self.av_tree.selection_set(found)
            self.av_tree.focus(found)
            self.av_tree.see(found)
            
            messagebox.showinfo("Paket SeÃ§ildi", f"'{room.display_name}' odasÄ± ve hizmetler seÃ§ildi.\nLÃ¼tfen 'Misafir AdÄ±' girip Rezervasyon Yap'a basÄ±n.")
            
            # 6. Ä°sme odaklan (EÄŸer referansÄ± varsa)
            if hasattr(self, "entry_guest"):
                self.entry_guest.focus_set()
        else:
            messagebox.showwarning("Dikkat", "Paket uygulandÄ± ancak oda listede bulunamadÄ±.\n(Belki baÅŸkasÄ± kaptÄ± veya filtre sorunu).")

    def on_undo(self) -> None:
        lbl = self.system.undo()
        if lbl is None:
            self.set_status("Undo yok.")
        else:
            self.set_status(f"Undo: {lbl}")
        self.refresh_all()

    def on_redo(self) -> None:
        lbl = self.system.redo()
        if lbl is None:
            self.set_status("Redo yok.")
        else:
            self.set_status(f"Redo: {lbl}")
        self.refresh_all()

    def refresh_reservations(self) -> None:
        if not self.winfo_exists(): return
        q = (self.filter_var.get().strip().lower() if hasattr(self, "filter_var") else "")
        if hasattr(self, "res_tree") and self.res_tree.winfo_exists():
            for i in self.res_tree.get_children():
                self.res_tree.delete(i)
            rows = self.system.list_reservations()
            for r in rows:
                if q:
                    hay = f"{r.res_id} {r.guest_name} {r.room_id} {r.room_type} {r.check_in}".lower()
                    if q not in hay:
                        continue
                people = r.adults + r.children
                self.res_tree.insert("", "end", values=(r.res_id, r.guest_name, r.room_id, r.room_type, r.check_in, r.check_out, people, r.total_price))

    def refresh_maintenance(self) -> None:
        if not self.winfo_exists(): return
        if hasattr(self, "mw_tree") and self.mw_tree.winfo_exists():
            for i in self.mw_tree.get_children():
                self.mw_tree.delete(i)
            for mw in self.system.list_maintenance():
                self.mw_tree.insert("", "end", values=(mw.mw_id, mw.scope, mw.scope_id, mw.start, mw.end))

    def refresh_summary(self) -> None:
        if not self.winfo_exists(): return
        res_count = len(self.system.reservations)
        start = today()
        end = today() + timedelta(days=30)
        rev_30 = 0
        for r in self.system.reservations.values():
            ci = parse_date(r.check_in)
            if start <= ci < end:
                rev_30 += int(r.total_price)

        if hasattr(self, "summary_var"):
            self.summary_var.set(
                f"Toplam Rezervasyon: {res_count}\n"
                f"Ã–nÃ¼mÃ¼zdeki 30 gÃ¼n (giriÅŸe gÃ¶re) gelir: {rev_30} TL\n"
                f"Waitlist: FAMILY4={len(self.system.waitlist['FAMILY4'])}, TRIPLE3={len(self.system.waitlist['TRIPLE3'])}, CELEB={len(self.system.waitlist['CELEB_FLOOR'])}"
            )
        if hasattr(self, "kpi_var"):
            self.kpi_var.set(f"Rezervasyon: {res_count}  â€¢  30g gelir: {rev_30} TL")

    def refresh_all(self) -> None:
        if not self.winfo_exists(): return
        # Not all widgets exist before first build
        if hasattr(self, "res_tree"):
            self.refresh_reservations()
        if hasattr(self, "mw_tree"):
            self.refresh_maintenance()
        if hasattr(self, "summary_var"):
            self.refresh_summary()
        if hasattr(self, "price_preview"):
            self.refresh_price_preview()
            # Also refresh preview canvas if exists
            if hasattr(self, "preview_canvas") and self.preview_canvas.winfo_exists():
                 self._draw_preview_map()



def main() -> None:
    import os
    data_dir = os.path.join(os.path.dirname(__file__), "data")
    system = HotelSystem(data_dir=data_dir)
    app = ModernHotelApp(system)
    app.mainloop()

if __name__ == "__main__":
    main()
